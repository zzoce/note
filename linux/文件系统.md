
# 文件存储

首先了解如下文件存储相关概念：inode、 dentry、 数据存储、文件系统。

### inode

其本质为 **==结构体==**，存储文件的属性信息。如：权限、类型、大小、时间、用户、盘块位置……也叫作文件属性管理结构，大多数的inode都存储在磁盘上。少量常用、近期使用的inode会被缓存到内存中。

### dentry

目录项，其本质依然是结构体，重要成员变量有两个 {文件名，inode，...}，而文件内容(data)保存在磁盘盘块中。

![[Pasted image 20240708195800.png]]

# 文件操作
### stat获取文件属性函数

获取文件属性，(从inode结构体中获取)
```cpp
#include <sys/stat.h>
int stat(const char *restrict pathname,struct stat *restrict statbuf); //成返回0；失败返回-1 设置errno为恰当值。
//参数1：文件名
//参数2：inode结构体指针 (传出参数)
```
文件属性将通过传出参数返回给调用者。
```cpp
struct stat {
    dev_t      st_dev;      /* ID of device containing file*/
    ino_t      st_ino;      /* Inode number inode号*/
    mode_t     st_mode;     /* File type and mode ，文件类型和访问权限*/
    nlink_t    st_nlink;    /* Number of hard links ，硬链接数*/
    uid_t      st_uid;      /* User ID of owner 。用户ID*/
    gid_t      st_gid;      /* Group ID of owner ，组ID*/
    dev_t      st_rdev;     /* Device ID (if special file) */
    off_t      st_size;     /* Total size, in bytes ，文件大小*/
    blksize_t  st_blksize;  /* Block size for filesystem I/O */
    blkcnt_t   st_blocks;   /* Number of 512 B blocks allocated */

    /* Since POSIX.1-2008, this structure supports nanosecond
	    precision for the following timestamp fields.
        For the details before POSIX.1-2008, see VERSIONS. */

    struct timespec  st_atim;  /* Time of last access ，访问时间*/
    struct timespec  st_mtim;  /* Time of last modification ，属性修改时间*/
    struct timespec  st_ctim;  /* Time of last status change ，内容修改时间*/
    
#define st_atime  st_atim.tv_sec  /* Backward compatibility */
#define st_mtime  st_mtim.tv_sec
#define st_ctime  st_ctim.tv_sec
};
```
练习：使用stat函数查看文件属性
```cpp
#include <iostream>
#include <cstring>
#include <error.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
using namespace std;
int main(int argc, char *argv[])
{
    struct stat sbuf;
    int ret = stat(argv[1], &sbuf);
    if (ret == -1)
    {
        perror("stat argv1");
        exit(1);
    }
    cout << "文件大小：" << sbuf.st_size << endl;

    return 0;
}  
```
![[Pasted image 20240708202050.png]]


### lstat函数
```cpp
int lstat(const char *path, struct stat *buf); //成返回0；失败返回-1 设置errno为恰当值。
```

练习：给定文件名，判断文件类型。文件类型判断方法：st_mode 取高4位。 但应使用宏函数：        
![[Pasted image 20240708204546.png]]

```cpp
S_ISREG(m)   is it a regular file?
S_ISDIR(m)   directory?
S_ISCHR(m)   character device?
S_ISBLK(m)   block device?
S_ISFIFO(m) FIFO (named pipe)?
S_ISLNK(m)   symbolic link?  (Not in POSIX.1-1996.)
S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
```
***也可以通过下面的方法实现***
![[Pasted image 20240709152735.png]]

***穿透符号链接：stat：会；lstat：不会***  


### 特殊权限位

包含三个二进制位。依次是：设置组ID位setGID；设置用户ID位setID；黏住位sticky
###### 黏住位

早起计算机内存紧，只有精要的常用的程序可以常驻物理内存，剩下的要暂存磁盘中。当内存不够用的时候会将该部分程序存回磁盘，腾出内存空间。若文件设置了黏住位，那么即使在内存比较吃紧的情况下，也不会将该文件回存到磁盘上。由于现阶段操作系统的虚拟内存管理分页算法完善。该功能已经被废弃。

但我们仍然 **==可以对目录设置黏住位==**。被设置了该位的目录，其内部文件只有：
1. 超级管理员
2. 该目录所有者
3. 该文件的所有者
以上三种用户有权限做删除、修改操作。其他用户可以读、创建但不能随意删除。

###### setUID位

进程有两个ID：EID(有效用户ID)，表示进程履行哪个用户的权限。
UID(实际用户ID)，表示进程实际属于哪个用户。

多数情况下，EID和UID相同。但是，当文件的setID被设置后两个ID则有可能不一样。

例如：当进程执行一个root用户的文件，若该文件的setID位被设置为1， 那么执行该文件时，进程的UID不变。EID变为root，表示进程开始履行root用户权限。

![[Pasted image 20240709010522.png]]setGID位于setID相类似。

### access函数

测试指定文件是否存在/拥有某种权限。

```cpp
int access(const char *pathname,  int mode); 
//成功/具备该权限：0；失败/不具备 -1 设置errno为相应值。
//参数2：R_OK、W_OK、X_OK
```
通常使用access函数来测试某个文件是否存在。F_OK

### chmod函数

修改文件的访问权限

```cpp
int chmod(const char *path, mode_t mode); //成功：0；失败：-1设置errno为相应值
int fchmod(int fd, mode_t mode);
```

### truncate函数

截断文件长度成指定长度。常用来拓展文件大小，代替lseek。

```cpp
int truncate(const char *path, off_t length); //成功：0；失败：-1设置errno为相应值
int ftruncate(int fd, off_t length);
```
### link/unlink创建删除硬链接函数
###### link函数
思考，为什么目录项要游离于inode之外，画蛇添足般的将文件名单独存储呢？？这样的存储方式有什么样的好处呢？

其目的是为了实现文件共享。Linux允许多个目录项共享一个inode，即共享盘块(data)。不同文件名，在人类眼中将它理解成两个文件，但是在内核眼里是同一个文件。

link函数，可以为已经存在的文件创建目录项(硬链接)。

```cpp
int link(const char *oldpath,  const char *newpath); //成功：0；失败：-1设置errno为相应值
```

注意：由于两个参数可以使用“相对/绝对路径+文件名”的方式来指定，所以易出错。

如：link("../abc/a.c", "../ioc/b.c")若a.c，b.c都对， 但abc，ioc目录不存在也会失败。

***mv命令既是修改了目录项，而并不修改文件本身。***

###### unlink函数

 删除一个文件的目录项；

```cpp
int unlink(const char *pathname); //成功：0；失败：-1设置errno为相应值
```

注意Linux下删除文件的机制：不断将st_nlink -1，直至减到0为止。无目录项对应的文件，将会被操作系统择机释放。(具体时间由系统内部调度算法决定)。因此，我们删除文件，从某种意义上说，***只是让文件具备了被释放的条件。***

**unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放，此时人可以通过文件描述符对文件操作，但都存在与内核缓存区上，并不会真的对硬盘操作。要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉**

练习：编程实现mv命令的改名操作`mymv.cpp`
```cpp
#include <iostream>
#include <link.h>
#include <fcntl.h>
#include <unistd.h>
#include <error.h>
#include <cstring>
using namespace std;
int main(int argc, char *argv[])
{
    int fd = open(argv[1], O_WRONLY);
    link(argv[1], argv[2]);//两个文件共用一个inode，也就是同一块磁盘块
    unlink(argv[1]);
    int ret = write(fd, "hello linux\n", strlen("hello linux\n"));
    //所以向可以写入到磁盘，而不仅仅是缓冲区
    if (ret == -1)
    {
        perror("write argv1");
        exit(1);
    }

    close(fd);
    return 0;
}
}
```
![[Pasted image 20240709001553.png]]
######  隐式回收

当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空间会被释放。系统的这一特性称之为隐式回收系统资源。

### symlink函数

创建一个符号链接

```cpp
int symlink(const char *oldpath, const char *newpath); 
//成功：0；失败：-1设置errno为相应值
```

### readlink函数

读取符号链接文件本身内容，得到链接所指向的文件名。

```cpp
ssize_t readlink(const char *path, char *buf, size_t bufsiz); 
//成功：返回实际读到的字节数；失败：-1设置errno为相应值。
```

### rename函数

重命名一个文件。
```cpp
int rename(const char *oldpath, const char *newpath); 
//成功：0；失败：-1设置errno为相应值
```

# 目录操作
工作目录：“./”代表当前目录，指的是进程当前的工作目录，默认是进程所执行的程序所在的目录位置。

### getcwd函数

获取进程当前工作目录 (卷3，标库函数)

```cpp
char *getcwd(char *buf, size_t size); 
//成功：buf中保存当前进程工作目录位置。失败返回NULL。
```

### chdir函数

改变当前进程的工作目录

```cpp
int chdir(const char *path); 
//成功：0；失败：-1设置errno为相应值
```

练习：获取及修改当前进程的工作目录，并打印至屏幕。 

### 文件、目录权限

注意：目录文件也是“文件”。其文件内容是该目录下所有子文件的目录项dentry。 可以尝试用vim打开一个目录。
![[Pasted image 20240709005332.png]]

|     |       R        |        W        |     X      |
| :-: | :------------: | :-------------: | :--------: |
| 文件  |   文件的内容可以被查看   |     内容可以被修改     | 可以运行产生一个进程 |
|     | cat、more、less… |     vi、> …      |   ./文件名    |
|     |                |                 |            |
| 目录  |    目录可以被浏览     |   创建、删除、修改文件    |  可以被打开、进入  |
|     |    ls、tree…    | mv、touch、mkdir… |     cd     |
当目录设置[[文件系统#黏住位|黏住位]]时：若有w权限，创建不变，删除、修改只能由root、目录所有者、文件所有者操作。

### opendir打开目录函数

根据传入的目录名打开一个目录 (库函数) DIR * 类似于 FILE *

```cpp
#include <sys/types.h>
#include <dirent.h>
DIR *opendir(const char *name);   
//成功返回指向该目录结构体指针，失败返回NULL
```
参数支持相对路径、绝对路径两种方式：例如：打开当前目录：① getcwd() , opendir() ② opendir(".");

### closedir关闭目录函数

关闭打开的目录

```cpp
int closedir(DIR *dirp); //成功：0；失败：-1设置errno为相应值
```

### readdir读目录函数

读取目录 (库函数)

```cpp
#include <dirent.h>
struct dirent *readdir(DIR *dirp);  
//成功返回目录项结构体指针；失败返回NULL设置errno为相应值
```

需注意返回值，读取数据结束时也返回NULL值，所以应借助errno进一步加以区分。

***struct 目录项结构体：***
```cpp
struct dirent {
	ino_t          d_ino;      //inode编号
    off_t          d_off;       
    unsigned short  d_reclen;    //文件名有效长度
    unsigned char   d_type;     //类型(vim打开看到的类似@*/等
    char          d_name[256];//文件名
};
```

其成员变量重点记忆两个：d_ino、d_name。实际应用中只使用到d_name。
```cpp
#include <iostream>
#include <link.h>
#include <fcntl.h>
#include <unistd.h>
#include <error.h>
#include <cstring>
#include <dirent.h>
using namespace std;
int main(int argc, char *argv[])
{
    DIR *dp;
    struct dirent *sdp;
    dp = opendir(argv[1]);
    if (dp == NULL)
    {
        perror("opendir error");
        exit(1);
    }
    while ((sdp = readdir(dp)) != NULL)
    {
        cout << sdp->d_name << "    ";
    }
    cout << endl;
    closedir(dp);
    return 0;
}
```

![[Pasted image 20240709013757.png]]

### telldir/seekdir函数

获取目录读写位置

```cpp
long telldir(DIR *dirp); //成功：与dirp相关的目录当前读写位置。失败-1，设置errno
```

修改目录读写位置

```cpp
void seekdir(DIR *dirp, long loc); //返回值：无
```

参数loc一般由telldir函数的返回值来决定。

### 递归遍历目录
**思路：**
```
判断命令行参数，获取用户要查询的目录名 argv[1]
	argc == 1 -->没有参数就是指当前文件夹
判断用户指定的是否是目录。stat S_ISDIR(); 封装函数判断是否是文件
读目录
	operdir();
	while (readdir()){
		普通文件：直接打印
		目录：
			拼接目录的绝对路径：sprintf (path ,"%s%s",dir,d_name);
			递归调用自己 ：opendir(path),readdir closedir
	}	
	closedir()；
```
**==代码实现：==**
#回调函数
```cpp
#include <iostream>
#include <link.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <error.h>
#include <cstring>
#include <dirent.h>
using namespace std;
#define PATH_LEN 256
void fetchdir(const char *dir, void (*fcn)(const char *))
{
    char name[PATH_LEN];
    struct dirent *sdp;
    DIR *dp;
    dp = opendir(dir);//打开文件夹
    if (dp == NULL)
    {
        perror("fetchdir cnat't open");
        exit(1);
    }
    while ((sdp = readdir(dp)) != NULL)//读文件夹中的目录项
    {
        if (strcmp(sdp->d_name, ".") == 0 || strcmp(sdp->d_name, "..") == 0)//防止循环
        {
            continue;
        }
        if (strlen(dir) + strlen(sdp->d_name) + 2 > PATH_LEN)
        {
            perror("name too long");
            exit(1);
        }
        else
        {
            snprintf(name, PATH_LEN, "%s/%s", dir, sdp->d_name);//合并文件目录
            (*fcn)(name);//回调isfile函数
        }
    }
    closedir(dp);
}

void isfile(const char *name) // 这是一个回调函数，作为 fetchdir的参数
{
    struct stat sbuf;
    if (stat(name, &sbuf) == -1) // 获取文件名属性，判断文件名是否有效
    {
        perror("stderr,isfile can't access");
        exit(1);
    }
    if ((sbuf.st_mode & S_IFMT) == S_IFDIR) // 判断是否是文件夹
    {
        fetchdir(name, isfile); // 调用函数，isfile作为参数传入，是一个回调函数
    }
    cout << sbuf.st_size << " " << name << endl; // 输出文件大小以及文件名
}
int main(int argc, char *argv[])
{
    if (argc == 1) // 没有参数，即遍历当前文件夹
    {
        isfile(".");
    }
    else
        while (--argc > 0) // 有多个参数，一次遍历

        {
            isfile(*++argv);
        }
    return 0;
}
```
![[Pasted image 20240713021521.png]]

# 重定向函数dup
[[Linux基础命令#重定向符|重定向符]]
### dup 和 dup2函数

```cpp
#include <fcntl.h>
#include <unistd.h>
int dup(int oldfd); 
//成功：返回一个新文件描述符；失败：-1设置errno为相应值
//oldfd： 旧的文件描述符
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
```

代码：
```cpp
#include <fcntl.h>
#include <unistd.h>
#include <iostream>
#include <fcntl.h>
#include <cstring>
using namespace std;
int main(int argc, char *argv[])
{
    int fd = open(argv[1], O_WRONLY);
    int newfd = dup(fd);
    cout << fd << " " << newfd << endl;
    close(fd);
    write(newfd, "123456789", 9);
    close(newfd);
    return 0;
}
```
![[Pasted image 20240713023510.png]]
### 三者区别
##### dup

`dup` 复制现有的文件描述符，并返回新的文件描述符。

```
#include <unistd.h>  int new_fd = dup(old_fd);
```

- `old_fd` 是要复制的文件描述符。
- `new_fd` 是新创建的文件描述符，它是系统中可用的最小的文件描述符。
- 新的文件描述符与原来的文件描述符共享同一个文件表项，因此它们指向同一个文件位置、访问模式和状态标志。

##### dup2

`dup2` 将现有文件描述符复制到指定的文件描述符。

```
#include <unistd.h>  
int result = dup2(old_fd, new_fd);
//dup2(fd,STDOOUT_FILENO);相当于将cout输出重定向到fd指向的文件
```

- `old_fd` 是要复制的文件描述符。
- `new_fd` 是要被复制到的文件描述符。如果 `new_fd` 已经被打开，它会首先被关闭。
- `dup2` 确保 `new_fd` 是你指定的值。

##### dup3

`dup3` 类似于 `dup2`，但多了一个标志参数，可以指定额外的选项。

```
#include <unistd.h> 
#include <fcntl.h>  
int result = dup3(old_fd, new_fd, flags);
```

- `old_fd` 是要复制的文件描述符。
- `new_fd` 是要被复制到的文件描述符。
- `flags` 是额外的标志，可以是 `O_CLOEXEC`。如果设置了 `O_CLOEXEC` 标志，那么新文件描述符在执行 `exec` 函数时会被自动关闭。
- `dup3` 提供了更细粒度的控制。

##### 区别总结

1. **功能差异**：
    
    - `dup`：仅复制文件描述符，并返回系统中可用的最小的文件描述符。
    - `dup2`：复制文件描述符到指定的文件描述符，并关闭目标文件描述符（如果已经打开）。
    - `dup3`：类似于 `dup2`，但允许指定额外的标志（如 `O_CLOEXEC`）。
2. **灵活性**：
    
    - `dup`：最简单的版本，只能创建新的文件描述符，不能控制新文件描述符的值。
    - `dup2`：允许指定新的文件描述符的值，提供了更多的控制。
    - `dup3`：除了 `dup2` 的功能外，还允许指定额外的标志，提供了最大的灵活性。
3. **用法场景**：
    
    - 使用 `dup`：当你只需要一个新的文件描述符，不关心它的具体值。
    - 使用 `dup2`：当你需要新的文件描述符具有特定值时。
    - 使用 `dup3`：当你需要新的文件描述符具有特定值，并且需要设置文件描述符标志时。