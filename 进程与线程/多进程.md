
# 1.基础知识

### 进程的基本概念

什么是进程？进程这个概念是针对系统而不是针对程序员的，对程序员来说，我们面对的概念是程序，当输入指令执行一个程序的时候，对系统而言，它将启动一个进程。

**==进程就是正在内存中运行中的程序==**，Linux下 **==一个进程在内存里有三部分的数据==**，就是“代码段”、”堆栈段”和”数据段”。
1. ”代码段”，顾名思义，就是存放了程序代码。
2. “堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。
3. “数据段”则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间）。

**==系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。==**


### 查看进程

###### ps 查看当前终端的进程

![[Pasted image 20240611074242.png]]

<mark style="background: #FF5582A6;">注意：</mark>
ps只显示当前终端的进程，如果在一号终端启动某个程序，在二号终端使用ps是查询不到的，

![[Pasted image 20240611080957.png]]

###### ps -ef 查看系统全部的进程。

![[Pasted image 20240611080315.png]]

ps -ef |more 查看系统全部的进程，结果分页显示。
![[Pasted image 20240611074745.png]]

1. UID ：启动进程的操作系统用户。
2. PID ：进程编号。
3. PPID ：进程的父进程的编号。
4. C ：CPU使用的资源百分比。
5. STIME ：进程启动时间。
6. TTY ：进程所属的终端。
7. TIME ：使用掉的CPU时间。
8. CMD ：执行的是什么指令。

<mark style="background: #FF5582A6;">注意</mark>
```
在分页查询时
	回车：显示下一行
	空格：显示多行
	按`q`键退出查看
```
###### 查找某个进程
ps -ef |grep book查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录。程序员用得最多的指令就是这个了。

![[Pasted image 20240611075220.png]]

 
### getpid函数获取进程编号
```cpp
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
int main()
{
    cout << "本程序进程为：" << getpid() << endl;
    sleep(120);
    cout << "hello Linux!" << endl;
    return 0;
}
```

运行结果
![[Pasted image 20240611082626.png]]

注意两个细节：

1）进程的编号是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。

2）进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。

# 2. 多进程

### 为什么要使用多进程

充分利用CPU资源，实现并发

### fork函数

fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。

fork函数用于产生一个新的进程，函数返回值pid_t是一个整数，**==在父进程中，返回值是子进程编号，在子进程中，返回值是0。==**

```cpp
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
int main()
{
    cout << "本程序进程为：" << getpid() << endl;
    int ipid = fork();
    sleep(1);
    cout << "父进程frok函数返回值" << ipid << endl;
    if (ipid == 0)
    {
        cout << "子进程编号是：" << getpid() << endl;
    }
    else
    {
        cout << "父进程编号是：" << getpid() << endl;
    }

    cout << "hello Linux!" << endl;
    sleep(120);
    return 0;
}
```

![[Pasted image 20240611085719.png]]



初学者可能用点接受不了现实。

1）一个函数（fork）返回了两个值？

2）if和else中的代码能同时被执行？

那么调用这个fork函数时发生了什么呢？fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。

fork函数对返回值做了特别的处理，调用fork函数之后，在子程序中fork的返回值是0，在父进程中fork的返回值仍是原进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。

