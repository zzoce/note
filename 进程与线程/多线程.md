[0. 课程目录-陈子青的编程学习课堂 (seestudy.cn)](http://www.seestudy.cn/?list_9/42.html)
[0.课程介绍_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1d841117SH/?p=1)

C++11 引入了原生的多线程支持，通过在标准库中添加 `<thread>`、`<mutex>`、`<condition_variable>` 和 `<atomic>` 等头文件，为开发者提供了创建和管理线程、同步操作等功能。这些功能是基于操作系统的底层线程管理功能（如 POSIX 线程或 Windows 线程）实现的，允许开发者在 C++ 程序中直接创建和控制线程。



# 线程（`std::thread`）

1. C++中的线程由 `std::thread` 类表示，它允许你指定一个函数或者函数对象，作为线程启动时执行的代码。
2. 创建线程后与主函数同步执行，有可能线程中的函数还没有执行完毕，主函数就已经完成了，导致程序出错。
3. 使用 `join()` 来等待线程完成其任务，或者使用`detach()`线程分离让线程在后台独立运行。
4. `joinable()`返回一个boo值，若县城可与被join()或者detach()则返回true，否则返回false

### 代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

void foo (){
    std::this_thread::sleep_for(std::chrono::seconds(1));//等待一秒
    cout<<"Thread started"<<endl;
}

int main ()
{
    thread t(foo);
    t.join();//等待t线程结束再执行后面的内容
	//t.detacg()//线程分离主函数结束线程依然在后台执行
	/*
	if(t.joinable){
		t.join();
	}
	*/
    cout<<"over"<<endl;
    return 0;
}
```

# 互斥量（`std::mutex`）

1. 互斥量`mutex` 用于保护共享数据，防止多个线程同时访问同一资源，但可能导致死锁
2. 死锁：线程一占用A资源申请B资源，线程二占用B资源申请A资源，导致两个线程互相等待导致死锁
3. `std::lock_guard` 和 `std::unique_lock` 是与互斥量配合使用的锁管理类，帮助保持良好的锁定习惯，防止死锁。

## 代码

### mutex

如下例代码预期输出data值为200000，若不采用互斥量独占，则data值小于200000，因为两个线程同时访问了data变量。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex mtx;//互斥量
void func(int n){
    for (int i=0;i<100000;i++){
        mtx.lock();//给线程独占，禁止其他前程访问，其他线程等待结束占用
        data+=1;
        mtx.unlock();//结束占用
    }
}

int main ()
{
    thread t1 (func,1);
    thread t2 (func,2);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```

### 死锁

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex m1,m2;//互斥量
void func_1(){
    m1.lock();
    std::this_thread::sleep_for(std::chrono::seconds(1));//等待一秒
    m2.lock();
    m1.unlock();
    m2.unlock();
}
void func_2(){
    m2.lock();
    m1.lock();
    m2.unlock();
    m1.unlock();
}
int main ()
{
    thread t1 (func_1);
    thread t2 (func_2);
    t1.join();
    t2.join();

    cout<<"over"<<endl;
    return 0;
}
```

### std::lock_guard和 std::unique_lock

#### lock_guard

`std::lock_guard` 是 C++ 标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。`std::lock_guard` 的特点如下：
- 当构造函数被调用时，该互斥量会被自动锁定。
- 当析构函数被调用时，该互斥量会被自动解锁。

**代码**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex mtx;
void func(){
    for (int i=0;i<100000;i++){
        lock_guard<mutex> lg(mtx);
        data++;
    }
}
int main ()
{
    thread t1 (func);
    thread t2 (func);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```

#### unique_lock

`std::unique_lock` 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。`std::unique_lock` 提供了以下几个成员函数：
- `lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。
- `try_lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 `false`，否则返回 `true`。
- `try_lock_for(const std::chrono::duration<Rep, Period>& rel_time)`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。
- `try_lock_until(const std::chrono::time_point<Clock, Duration>& abs_time)`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。
- `unlock()`：对互斥量进行解锁操作。
    
**代码**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
timed_mutex mtx;//支持时间操作的互斥量
void func(){
    for (int i=0;i<5;i++){
        unique_lock<timed_mutex> lg(mtx,defer_lock);//第二个参数表示有限时的等待
        //unique_lock<timed_mutex> lg(mtx);
        if (lg.try_lock_for(chrono::seconds(1))){//等待时间超过1秒就返回false
            this_thread::sleep_for(chrono::seconds(2));//延时两秒
            data++;
        }

    }
}
int main ()
{
    thread t1 (func);
    thread t2 (func);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```


# 单例模式

单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，可能会导致多个对象被创建，违反了单例模式要求。

`std::call_once` 是 C++11 标准库中的一个函数，用于确保某个函数只会再多线程下只被调用一次。确保单例模式的对象只被创建一个。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

class Singleton{
public:
    static Singleton& getInstance(){
        call_once(m_onceFlag,&Singleton::init);
        return *m_instance;
    }
    void setData(int data){
        m_data+=data;
    }
    int getData() const{
        return m_data;
    }
private:
    Singleton (){}
    Singleton(const Singleton&)=delete;
    Singleton operator=(const Singleton&)=delete;
    static void init(){
        m_instance.reset(new Singleton);
    }
    static unique_ptr<Singleton> m_instance;
    static once_flag m_onceFlag;
    int m_data=0;
};

unique_ptr<Singleton> Singleton::m_instance;
once_flag Singleton::m_onceFlag;

void func(int num){
    Singleton &Snum=Singleton::getInstance();
    Snum.setData(num);
    cout<<Snum.getData()<<endl;
    return ;
}
void fun(int num){
    int a=0;
    a+=num;
    cout<<num<<endl;
    return ;
}

int main ()
{
    thread t1(func,10);
    std::this_thread::sleep_for(std::chrono::seconds(1));//延时一秒
    thread t2(func,20);
    t1.join();
    t2.join();

    cout<<"over"<<endl;
    return 0;
}
```


# 条件变量（`std::condition_variable`）

1. 条件变量用于线程间的同步，可以使一个或多个线程在某些条件下阻塞，直到另一个线程修改条件并通知条件变量。
2. 通常与互斥量一起使用，以保证条件检查和条件变更的原子性。

**==std::condition_variable的步骤如下：==**

1. 创建一个 `std::condition_variable` 对象。
2. 创建一个互斥锁 `std::mutex` 对象，用来保护共享资源的访问。
3. 在需要等待条件变量的地方使用 `std::unique_lock<std::mutex>` 对象锁定互斥锁，并调用 `std::condition_variable::wait()`、`std::condition_variable::wait_for()` 或 `std::condition_variable::wait_until()` 函数等待条件变量。
4. 在其他线程中需要通知等待的线程时，调用 `std::condition_variable::notify_one()`或 `std::condition_variable::notify_all()` 函数通知等待的线程。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
std::mutex g_mutex;
std::condition_variable g_cv;
std::queue<int> g_queue;

void Producer() {
    for (int i = 0; i < 10; i++) {
        {//用于unique_lock自动析构
            std::unique_lock<std::mutex> lock(g_mutex);//互锁
            g_queue.push(i);//任务入队
            std::cout << "Producer: produced " << i << std::endl;
        }
        g_cv.notify_one();//新任务已经入队，通知其他线程
        std::this_thread::sleep_for(std::chrono::milliseconds(100));//休眠100毫秒
    }
}
void Consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(g_mutex);//互锁

        //等待!g_queue.empty()==true条件满足，如果不满足就先执行其他线程
        g_cv.wait(lock, []() { return !g_queue.empty(); });
        //执行
        int value = g_queue.front();
        g_queue.pop();

        //输出
        std::cout << "Consumer: consumed " << value << std::endl;
    }
}
int main() {
    std::thread producer_thread(Producer);
    std::thread consumer_thread(Consumer);
    producer_thread.join();
    consumer_thread.join();
    return 0;
}
```





# 跨平台线程池

为什么使用线程池，因为线程的开辟和销毁都是一个非常消耗资源耗费时间的事情，所以提前开辟好一堆线程，专门等待被使用，就可以大大提高处理任务的效率
![[Pasted image 20240610213220.png]]

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <queue>

class ThreadPool {
public:
    ThreadPool(int numThreads) : stop(false) {//线程池
        for (int i = 0; i < numThreads; ++i) {
            threads.emplace_back([this] {//lambda表达式
                while (true) {
                    std::unique_lock<std::mutex> lock(mutex);
                    condition.wait(lock, [this] { return stop || !tasks.empty(); });
                    if (stop && tasks.empty()) {
                        return;
                    }
                    std::function<void()> task(std::move(tasks.front()));//function,move语义
                    tasks.pop();
                    lock.unlock();
                    task();
                }
            });
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread& thread : threads) {
            thread.join();
        }
    }


//任务对列
    template<typename F, typename... Args>//可变参数，函数模板
    void enqueue(F&& f, Args&&... args) {//万能引用，左值引用，右值引用
        std::function<void()> task(std::bind(std::forward<F>(f), std::forward<Args>(args)...));//function 函数适配器bind 完美转发forward
        {
            std::unique_lock<std::mutex> lock(mutex);
            tasks.emplace(std::move(task));
        }
        condition.notify_one();
    }

private:
    std::vector<std::thread> threads;
    std::queue<std::function<void()>> tasks;
    std::mutex mutex;
    std::condition_variable condition;
    bool stop;
};

int main() {
    ThreadPool pool(4);
    for (int i = 0; i < 8; ++i) {
        pool.enqueue([i] {
            std::cout << "Task " << i << " is running in thread " << std::this_thread::get_id() << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            std::cout << "Task " << i << " is done" << std::endl;
        });
    }
    return 0;
}
```

# 异步并发


> [!NOTE] 知识小贴士
> **==异步编程本身并不能确保数据不冲突==**。数据冲突问题（数据竞争）通常发生在多个线程或任务同时访问和修改共享数据而没有适当的同步机制的情况下。要确保数据不冲突，必须使用适当的同步原语或并发数据结构，即使在异步编程中也是如此。

### 异步并发和多线程比较
###### 异步并发

异步并发是一种编程模型，它允许程序在执行某个任务的同时继续执行其他任务，而不必等待前一个任务的完成。在异步并发中，任务的执行是非阻塞的，程序可以在任务执行的过程中继续做其他事情。异步并发通常使用以下几种技术来实现：

1. **回调函数**：通过注册回调函数，当某个任务完成时会自动调用相应的回调函数。
2. **事件循环**：程序通过事件循环来处理任务，当有任务完成时，会触发相应的事件，然后执行相应的处理逻辑。
3. **Future/Promise**：Future 表示一个异步操作的结果，Promise 用于设置异步操作的结果，并通知 Future。

异步并发通常用于 I/O 密集型的任务，比如网络请求、文件读写等，以避免因等待 I/O 操作而浪费 CPU 时间。

###### 多线程

多线程是指在一个程序中同时运行多个线程，每个线程都可以独立执行不同的任务。多线程可以实现真正的并行执行，提高程序的性能。在多线程编程中，通常使用以下几种技术来实现并发：

1. **线程库**：使用线程库（如 C++ 的 `<thread>` 库）来创建和管理线程。
2. **锁机制**：使用锁来保护共享资源，防止多个线程同时访问和修改共享数据。
3. **条件变量**：用于线程间的通信和同步，一个线程可以等待另一个线程满足某个条件后再继续执行。

多线程通常用于 CPU 密集型的任务，比如计算密集型的算法、图形渲染等，以充分利用多核 CPU 的性能。

###### 区别

1. **执行方式**：
    
    - 异步并发通常是在单个线程中执行多个任务，通过非阻塞的方式来实现并发。
    - 多线程是在多个线程中同时执行多个任务，通过真正的并行执行来提高程序的性能。
2. **适用场景**：
    
    - 异步并发适用于 I/O 密集型的任务，可以避免因等待 I/O 操作而浪费 CPU 时间。
    - 多线程适用于 CPU 密集型的任务，可以充分利用多核 CPU 的性能。
3. **编程模型**：
    
    - 异步并发通常需要使用特定的编程模型（如事件驱动、Future/Promise），用于处理异步操作的结果和事件。
    - 多线程编程需要考虑线程间的同步和通信，通常需要使用锁、条件变量等同步机制来保护共享资源和实现线程间的协作。
4. **开销**：
    
    - 异步并发通常比多线程的开销更低，因为它不需要创建和管理多个线程，而是在单个线程中实现并发。
    - 多线程的开销相对较高，因为需要创建和管理多个线程，而且需要考虑线程间的同步和通信问题。

###### 结论

异步并发和多线程都是处理并发任务的重要方法，它们各有优势和适用场景。在实际开发中，根据任务的性质和需求选择合适的并发模型，可以提高程序的性能和可维护性。
### async 、 future

是C++11引入的一个函数模板，**==用于异步执行一个函数==**，并返回一个std::future对象，表示异步操作的结果。使用std::async可以方便地进行异步编程，**==避免了手动创建线程和管理线程的麻烦==**。下面是一个使用std::async的案例：  
  

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
#include <future>
#include <condition_variable>
using namespace std;
int func()
{
    int ans = 0;
    for (int i = 1; i <= 1000; i++)
    {
        ans++;
    }
    return ans;
}

int main() 
{
    future<int> future_result =async(launch::async,func);
    cout<<func ()<<endl;
    cout<<future_result.get()<<endl;

    return 0;
}
```

  
  
这个例子中，我们使用std::async函数异步执行了一个耗时的计算，这个计算可以在另一个线程中执行，不会阻塞主线程。同时，我们也避免了手动创建线程和管理线程的麻烦。  

***启动策略***

`std::async` 是 C++11 引入的一个用于启动异步任务的工具。它的启动策略可以通过 `std::launch` 参数来控制，具体有两种策略：

1. **`std::launch::async`**：任务会立即在新线程中异步启动，在后台运行。
2. **`std::launch::deferred`**：任务会延迟到 `future` 的 `get()` 或 `wait()` 方法被调用时才执行，也就是在调用线程中同步执行。



###  packaged_task

在C++中，packaged_task是一个类模板，**==用于将一个可调用对象（如函数、函数对象或Lambda表达式）封装成一个异步操作==**，并返回一个std::future对象，表示异步操作的结果。**==packaged_task可以方便地将一个函数或可调用对象转换成一个异步操作，供其他线程使用==**。  
  
以下是packaged_task的基本用法：  
  
1. 定义可调用对象  
  
```cpp
int calculate(int x, int y) {
    return x + y;
}
```

这里定义了一个函数calculate，用于将两个整数相加。  
  
2. 创建packaged_task对象  
  
```cpp
std::packaged_task<int(int, int)> task(calculate);
std::future<int> future_result = task.get_future();
```

这里创建了一个packaged_task对象，将函数calculate封装成异步操作，并返回一个std::future对象，表示异步操作的结果。  
  
3. 在其他线程中执行异步操作  
  

```cpp
std::thread t(std::move(task), 1, 2);
t.join();
```
  
  
这里创建了一个新的线程，并在这个线程中执行异步操作。***由于packaged_task对象是可移动的，因此需要使用std::move()函数将task对象转移至新线程中执行。***  
  
4. 获取异步操作的结果  
  
```cpp
int result = future_result.get();
std::cout << result << std::endl; // 输出3
```

  
在主线程中，我们可以使用future_result.get()方法获取异步操作的结果，并输出到控制台。  在这个例子中，我们成功地将一个函数calculate封装成了一个异步操作，并在其他线程中执行。通过packaged_task和future对象，我们可以方便地实现异步编程，使得代码更加简洁和易于维护。

### packaged_task与 std::async的比较

- **`std::packaged_task`**：
    
    - 适用于需要显式控制任务何时、如何执行的场景。
    - 可以在任意线程或上下文中启动任务，提供了更多的灵活性。
    - 需要显式管理线程或执行上下文。
- **`std::async`**：
    
    - 更简单方便，适用于快速启动异步任务。
    - 自动管理任务的启动和执行，无需显式管理线程。
    - 可以指定启动策略（同步或异步），如 `std::launch::async` 或 `std::launch::deferred`。
  

### promise

在C++中，promise是一个类模板，用于在一个线程中产生一个值，并在另一个线程中获取这个值。promise通常与future和async一起使用，用于实现异步编程。  
  
以下是promise的基本用法：  
  
1. 创建promise对象  
  
```cpp
std::promise<int> p;
```

这里创建了一个promise对象，用于产生一个整数值。  
  
2. 获取future对象  
  
```cpp
std::future<int> f = p.get_future();
```

通过promise对象的get_future()方法，可以获取与之关联的future对象，用于在另一个线程中获取promise对象产生的值。  
  
3. 在其他线程中设置值  
```cpp
std::thread t([&p]() {
    p.set_value(42);
});
t.join();
```

这里创建了一个新的线程，并在这个线程中，使用promise对象的set_value()方法设置一个整数值42。  
  
4. 在主线程中获取值  
```cpp
int result = f.get();
std::cout << result << std::endl; // 输出42
```
  
在主线程中，我们可以使用future对象的get()方法获取promise对象产生的值，并输出到控制台。  

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
#include <future>
#include <condition_variable>
using namespace std;
void func(promise<int> &f)
{
    int ans = 0;
    for (int i = 1; i <= 100000; i++)
    {
        ans++;
    }
    f.set_value(ans);
}

int main() 
{
    promise <int> f;
    auto future_result =f.get_future();

    thread t1 (func,ref(f));

    cout<<future_result.get()<<endl;

    return 0;
}
```

在 C++ 中，使用 `std::promise` 和 `std::future` 进行线程间通信时，共享状态的值通常只能设置一次，也就是说，`std::promise` 只能调用一次 `set_value` 方法。一旦 `set_value` 被调用，关联的 `std::future` 将获得这个值，并且共享状态不再允许修改。因此，在这个具体用例中，共享状态的值不是不断变化的。

如果你需要在多个线程间共享和不断更新一个值，可以使用其他同步机制，如 `std::mutex` 和 `std::condition_variable`，或使用更高级的并发数据结构（如 `std::atomic` 或 `std::shared_mutex`）。

# 原子操作（`std::atomic`）

1. 原子类型用于无锁编程，保证类型操作的原子性，避免在多线程环境中的数据竞争。
2. 提供了一种更细粒度的同步机制，通常用于计数器或状态标志。

`std::atomic` 是 C++11 标准库中的一个模板类，用于实现多线程环境下的原子操作。它 **==提供了一种线程安全的方式来访问和修改共享变量，可以避免多线程环境中的数据竞争问题。==**  
  
`std::atomic` 的使用方式类似于普通的 C++ 变量，但是它的操作是原子性的。也就是说，在多线程环境下，多个线程同时对同一个 `std::atomic` 变量进行操作时，**==不会出现数据竞争问题。==**  
  
以下是一些常用的 `std::atomic` 操作：  
  
1. `load()`：将 `std::atomic` 变量的值加载到当前线程的本地缓存中，并返回这个值。  
  
2. `store(val)`：将 `val` 的值存储到 `std::atomic` 变量中，并保证这个操作是原子性的。  
  
3. `exchange(val)`：将 `val` 的值存储到 `std::atomic` 变量中，并返回原先的值。  
  
4. `compare_exchange_weak(expected, val)` 和 `compare_exchange_strong(expected, val)`：比较 `std::atomic` 变量的值和 `expected` 的值是否相同，如果相同，则将 `val` 的值存储到 `std::atomic` 变量中，并返回 `true`；否则，将 `std::atomic` 变量的值存储到 `expected` 中，并返回 `false`。  
  
以下是一个示例，演示了如何使用 `std::atomic` 进行原子操作：
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
#include <future>
#include <condition_variable>
#include <atomic>
using namespace std;
atomic <int> shared_data =0;
void func()
{
    
    for (int i = 1; i <= 100000; i++)
    {
        shared_data++;
    }
    
}

int main() 
{
    thread t1 (func);
    cout << shared_data.load() << endl;

    thread t2(func);
    cout << shared_data.load() << endl;

    t1.join();
    t2.join();

    cout << shared_data << endl;

    shared_data.store(1234);
    cout << shared_data << endl;

    return 0;
}
```

### 原子的一些操作

`std::atomic` 是 C++11 引入的原子类型，用于在多线程环境中对变量进行原子操作，从而避免数据竞争和并发访问的问题。以下是 `std::atomic` 可以执行的一些操作：

1. **加载（Load）**：获取原子对象的当前值。
```cpp
std::atomic<int> atomic_int{42};
int value = atomic_int.load();
```
2. **存储（Store）**：将给定的值存储到原子对象中。
```cpp
std::atomic<int> atomic_int{42};
atomic_int.store(10);
```
3. **交换（Exchange）**：将给定的值存储到原子对象中，并返回原子对象的旧值。
```cpp
std::atomic<int> atomic_int{42};
int old_value = atomic_int.exchange(10);
```
4. **比较和交换（Compare and Exchange，通常称为 CAS）**：如果当前值等于预期值，则将新值存储到原子对象中，并返回 true；否则，不做任何操作，并返回 false。
```cpp
std::atomic<int> atomic_int{42};
int expected = 42;
int new_value = 10;
bool success = atomic_int.compare_exchange_strong(expected, new_value);
```
5. **增加和减少（Add and Subtract）**：将给定的增量加到原子对象的当前值上，或从原子对象的当前值中减去给定的减量。
```cpp
std::atomic<int> atomic_int{42};
atomic_int += 10; // 等价于 atomic_int.fetch_add(10)
atomic_int -= 5;  // 等价于 atomic_int.fetch_sub(5)
```
6. **递增和递减（Increment and Decrement）**：将原子对象的当前值加一或减一，并返回递增或递减前的值。
```cpp
std::atomic<int> atomic_int{42};
int old_value = atomic_int++;
int new_value = --atomic_int;
```
7. **位操作（Bitwise Operations）**：原子地进行位与、位或、位异或等操作。
```cpp
std::atomic<int> atomic_int{42};
atomic_int &= 0x0F; // 位与操作
atomic_int |= 0x80; // 位或操作
atomic_int ^= 0x08; // 位异或操作
```
8. **内存顺序设置（Memory Order Setting）**：指定原子操作的内存顺序，如 `std::memory_order_relaxed`, `std::memory_order_acquire`, `std::memory_order_release`, `std::memory_order_seq_cst` 等。
 ```cpp
std::atomic<int> atomic_int{42};
atomic_int.fetch_add(10, std::memory_order_acquire);
```

这些操作可以确保对原子对象的操作是线程安全的，并且在多线程环境中不会发生数据竞争。通过使用 `std::atomic`，可以更容易地编写并发程序，提高程序的正确性和可移植性。
# 作业：交替打印A和B

在 C++ 中实现两个线程交替打印字符A和B各100次，可以使用标准库中的多线程支持，如 `std::thread`，以及同步机制如 `std::mutex` 和 `std::condition_variable`。下面是一个示例程序，展示如何使用这些工具来确保两个线程可以交替执行。

### 示例代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

// 共享资源和同步的相关变量
std::mutex mtx;
std::condition_variable cv;
bool turn = true; // true 表示打印A，false 表示打印B

void print_char(char c, bool my_turn) {
    for (int i = 0; i < 100; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        // 等待正确的条件
        cv.wait(lock, [&]() { return turn == my_turn; });
        // 打印字符
        std::cout << c;
        // 切换轮次
        turn = !turn;
        // 通知其他线程
        cv.notify_one();
    }
}

int main() {
    // 创建两个线程
    std::thread t1(print_char, 'A', true);
    std::thread t2(print_char, 'B', false);

    // 等待线程结束
    t1.join();
    t2.join();

    std::cout << "\nFinished printing." << std::endl;

    return 0;
}
```

### 代码解释

1. **全局变量**：
   - `std::mutex mtx`：互斥量，用于同步对共享资源的访问。
   - `std::condition_variable cv`：条件变量，用于在某种条件下阻塞线程或唤醒线程。
   - `bool turn`：布尔标志，用于控制哪个线程应该打印，以确保A和B交替打印。

2. **函数 `print_char`**：
   - 接受一个字符和一个布尔值，字符表示要打印的字符，布尔值表示该线程的打印轮次。
   - 循环100次，每次循环中，线程首先获取互斥锁。
   - 使用条件变量等待正确的轮次。
   - 打印字符后，切换轮次，并通知其他可能在等待的线程。

3. **主函数 `main`**：
   - 创建两个线程，一个打印'A'，另一个打印'B'。
   - 通过 `join()` 等待这两个线程执行完毕。

### 注意事项

- 使用 `std::cout` 在多线程中可能不是线程安全的，但在这个特定的示例中，由于互斥锁的保护，可以安全地使用。
- 确保线程在任何时候只有一个能够访问共享资源，这里的共享资源是标准输出和控制打印顺序的变量。

这种方式确保了两个线程能够有效且正确地交替执行，同时保持代码的简洁性和易于理解。
