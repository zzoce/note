# 计算机网简史

###### 1.电路交换
![[Pasted image 20240512195627.png]]
双方独占线路，即便不通信别人也不能够使用。效率低

###### 2.报文交换
整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点

###### 3.分组交换
将报文分组传输，每组报文都由 **首部和数据段**组成，
![[Pasted image 20240512193557.png]]
**==交换方式==**：存储转发
节点收到分组，先暂时存储下来，在检查首部按照首部中的目的地址，来转发。
![[Pasted image 20240512194018.png]]
逐段占用线路，节省资源提高利用率

####  因特网发展史

最早的计算机网络是美国建立的ARPA，但无法链接不同类型的计算机和不同类的操作系统。1983年 **==TCP/IP==** 协议成为因特网的标准协议，一直至今。

###### 三级结构的因特网
![[Pasted image 20240512200356.png]]

###### 多级结构因特网
![[Pasted image 20240512200455.png]]

###### 按照网络的作用范围分类
1. **广域网WAN**：覆盖范围广泛，传输距离远，链接不用的地区和国家
2. **城域网MAN**：覆盖范围一般为一个城市，常作为公共设施
3. **局域网LAN**：地理范围较小，如一个小区，大学，企业等等
4. **个人局域网PAN**：主要用于打通个人家庭或办公室一些电子设备，作用范围较小


# TCP/IP协议

为使不同的电子设备，操作系统之间可以互联而提出的一套计算机通信协议。其由很多协议组成，**==称为TCP/IP族==**

###### 分层结构
![[Pasted image 20240512203033.png]]


1. **OSI的七层协议：** 概念清楚，理论也较完整，但它既复杂又不实用。
    - 应用层  
        - HTTP(用于传输超文本的协议)和HTTPS： HTTPS多了一个SSL加密，更安全，且端口号不同（常用于Web服务器和客户端之间的通信）![[Pasted image 20240529213315.png]]  
        - FTP：文件传输协议（file transmation protocal）  
        - DNS：域名解析协议，解析成IP地址  
        - DHCP：动态主机配置协议，可以自动获取网络配置，IP地址（如登录校园网时会自动给你分配IP等东西）  
    - 表示层  
        - 数据格式转换，数据加解密，数据压缩解压缩，图片/视频编解码  
    - 会话层  
        - session会话管理（打开新的界面时不用再次登录），服务器验证用户登录，断点续传  
    - 传输层  
        - TCP（传输控制协议，面向连接的，可靠的，基于字节流的传输层通信协议）， UDP（用户数据报协议，面向无连接的，高效率，低可靠性的数据传输服务）， 线程，端口（端口号是为了找到具体的应用程序，一个应用程序可以使用多个端口号，一个端口号只能被一个应用程序使用）， socket(套接字)通信的基石（包含连接使用的协议，IP地址，端口号）  
    - 网络层  
        - 防火墙，IP，ARP（地址解析协议，根据IP地址寻找MAC地址），PARP  
    - 数据链路层![[Pasted image 20240529213208.png]]
        - 网卡（一个网卡对应一个IP地址），交换机（在连接在同一个交换机上的设备之间转发数据，不同交换机之间不能交换数据），路由器（各个路由器之间可以交换数据），MAC地址（物理地址，永久不变，全球唯一）
2. **TCP/IP 四层协议**：，包含应用层、运输层、网际层和网络接口层(用网际层这个名字是强调这一层是为了解决不同网络的互连问题)。不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容。***得到了非常广泛的应用。***
3. **五层协议**：在学习计算机网络的原理时往往采取折中的办法，即综合OSI和TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚 。有时为了方便，也可把最底下两层称为网络接口层


###### 各层协议
1. **应用层**：应用程序之间沟通的层，例如：
	1. FTP文件传输，
	2. Telnet，
	3. HTTP：用于传输超文本的协议，HTTPS： HTTPS多了一个SSL加密，更安全，且端口号不同常用于Web服务器和客户端之间的通信
	4. DNS域名解析协议，
	5. DHCP动态主机配置协议，可以自动获取网络配置，IP地址（如登录校园网时会自动给你分配IP等东西）等
2. **传输层**：提供进程间的数据传送服务，负责传送数据，提供应用程序端到端的逻辑通信。例如：TCP，UDP。
3. **网络层**：提供基本的***数据封包传输功能***，最大可能的让每个数据包都能够到达目的主机。例如：IP（网际协议），ICMP，ARP，RARP。
4. **链路层**：负责数据帧的发送和接受。帧是一个数据单位

###### 数据传送流程

每层完成自己的任务，最终通过不同的层次的处理完成数据的收发
![[Pasted image 20240512204655.png]]
![[Pasted image 20240512204410.png]]


#### 各个协议简介

###### ARP协议
[[网络通信过程#通信过程-交换机|ARP协议]]：地址解析协议（address resolution protocal）根据IP地址获取物理地址（MAC地址）
1. PC1找PC2，PC1发送时MAC地址采用广播（全F），因为他不知道目的MAC地址，只能给所有人都发
2. PC2回应的时候采用单播，返回自己的MAC地址以及其他的数据

**==ARP代理（当源设备和目的设备不在同一网络下时的解决方法）==**
当要找的设备不在当前共同网络下，本地网络上将不会有主机回应（因为IP地址是外网的），此时路由器将会回应该请求，则发送源误认为路由器就是主机，会将报文全部转发给他，再由路由器转发报文到外网，则该路由器被称为ARP代理。

**==免费ARP（1，保证本地网络上IP地址的唯一，2，宣发自己的IP—MAC对==**
![[Pasted image 20240530111121.png]]

###### DNS协议
DNS协议：域名解析协议（Domain name resolution）将域名解析成IP地址，所有的 **==本地服务器DNS表中若没有就会去DNS根服务器中询问==**，找到以后本地服务器会先将域名及对应的IP写入缓存
![[Pasted image 20240530111227.png]]
***根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路***
###### IP协议
特指为实现在一个相互连接的网络系统上从源地址到目的地传输数据包（互联网数据包）所提供必要功能的协议
**==特点:==**
	不可靠:它 **==不能==** 保证IP 数据包能成功地到达它的目的地，仅提供尽力而为的传输服务
	无连接:IP 并不维护任何关于后续数据包的状态信息。每个数据包的处理是相互独立的。**==IP 数据包可以不按发送顺序接收==**

***IP 数据包中含有发送它主机的 IP 地址(源地址) 和接收它主机的 IP 地址(目的地址)***

###### TCP协议

**又称传输控制协议，TCP 是一种面向==连接的,可靠的，基于字节流==传输层通信协议**

**功能:**
	提供不同主机上的进程间通信
**特点：**
1. 建立链接->使用链接->释放链接(虚电路)
2. TCP 数据包中 **==包含序号和确认序号==**，
3. ***对包进行排序并检错，而损坏的包可以被重传***

**服务对象**
需要高度可靠性且面向连接的服务，如 HTTP（网页）、FTP（文件）、SMTP（邮件） 等

###### UDP协议

用户数据报协议，UDP 是一种面向 **==无连接的，高效率，低可靠性==** 传输层通信协议

**功能:**
	提供不同主机上的进程间通信
**特点**
1. 发送数据之前不需要建立链接，直接传，为了快！
2. 不对数据包的顺序进行检查，不安全，为了快！！
3. 没有错误检测和重传机制，为了快！！！

**服务对象**
主要用于 **“查询一应答”** 的服务，如: NFS、NTP、DNS等
**应用**：
一些对速度有高要求，而不关心数据包是否接收到的场景，**==也就是一些实时性高的场景==**，例如：语音或视频通话，直播


# MAC地址，IP地址，NetMask（子网掩码），端口

###### 网卡
通过网卡来实现不同计算机之间的链接，每一个网卡在出厂时分配一个号码，就是MAC地址
![[Pasted image 20240513133712.png]]

###### MAC地址

网卡在出场时分配的号码，就是MAC地址，类似与身份证号，理论上是全球唯一的，但实际上MAC地址可以修改。
**组成**：在以太网内MAC地址是一个48bit的值，由16进制表示，**==分为六组，每组用:或-隔开==**，前三组为厂商ID，后三组为设备ID
![[Pasted image 20240513134549.png]]



###### IP地址
IP地址是一种Internet上的主机编址方式，也成为网际协议，IP地址是计算机在网络中的唯一标识
linux查看IP地址命令`ifconfig`

**IPv4**：占32位，不够用，必须通过分级方式才行，一般使用点分十进制字符串标识，比如192.168.3.1，由两部分组成
子网ID：IP地址中由子网掩码中1覆盖的连续位
主机ID：IP地址中由子网掩码中0覆盖的连续位
![[Pasted image 20240513135854.png]]
**==特点==：**
1. 子网ID不同的网络不能直接通信，如果要通信则需要路由器转发
2. 主机ID全为0的地址表示网段地址
3. 主机ID全为1的地址表示该网段的广播地址

**==分类==**：
1. A类地址: 默认8bit子网ID,第一位为0，前八位00000000 - 01111111,范围0.x.x.x 127.x.x.x
2. B类地址 : 默认16bit子网ID,前两位为10，前从位10000000 - 10111111,范围128.x.x.x-191.x.x.x
3. C类地址: 默认24bit子网ID,前三位为110,前八位11000000 11011111,范围192.x.x.x-223.x.x.x
4. D类地址: 前四位为1110,多播地址
5. E类地址: 前五位为11110,保留为今后使用

**==私有IP==**
公有IP：可以直接链接Internet，经由InterNIC所统一规划
私有IP：不可以直接链接Internet，主要用于局域网的主机联机规划

![[Pasted image 20240513143956.png]]

**==回环地址==**
通常$127.0.0.1$称为回环地址，主要是测试本机的网络配置，能ping通$127.0.0.1$就说明本机的网卡和IP协议安装都没有问题
<mark style="background: #FF5582A6;">注意</mark>：$127.0.0.1-127.255.255.254$中的任何地址都将回环到本地主机中，不属于任何一个有类别地址类，它代表设备的本地虚拟接口 

![[Pasted image 20240529215319.png]]

**IPv6**: 占64位，完全够用，可以支持地球上的每一个计算机都有自己的IP地址，可以轻松的实现远程访问。

###### 子网掩码
子网掩码又叫网络掩码，地址掩码是一个32bit由1和0组成的编码，并且1和0分别连续
**==作用==**：
指明IP地址中哪些是子网ID哪些是主机ID
**==特点==**：
必须与IP地址一起使用，不能单独存在
IP地址中由子网掩码中1覆盖的连续位为子网ID，其余为主机ID
**==默认子网掩码==**：
A类IP地址：255.0.0.0
B类IP地址：255.255.0.0
C类IP地址：255.255.255.0
**==非默认子网掩码==**
一定是在默认子网掩码的基础上多几个1，不可能少
![[Pasted image 20240529215621.png]]

###### 端口
**==端口概述==**
TCP/IP 协议采用端口标识通信的进程，用于区分一个系统里的多个进程
**==特点==**
1. 对于同一个端口，在本同系统中对应着不同的进程
2. 对于同一个系统，一个端口只能被一个进程拥有
3. 一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交传输层的数据也
通过该端口被送出

###### 端口号

类似 pid 标识一个进程；在网络程序中，用端口号(port)来标识一个运行的网络程序
**==特点==**
1. 端口号是无符号短整型的类型
2. 每个端口都拥有一个端口号
3. <mark style="background: #FFB8EBA6;">TCP、UDP 维护各自独立的端口号</mark>
4. 网络应用程序,至少要占用一个端口号,也可以占有多个端口号

**==想一想==**
	为什么有了 pid，还需要端口来标识一个进程呢?
	pid由系统分配，会发生变化，端口号是固定的不会发生变化。

**==知名端口( 1~1023 )==**
	由互联网数字分配机构(IANA)根据用户需要进行统一分配，例如: FTP-21，HTTP-80等
	服务器通常使用的范围；若强制使用，须加root特权

**==动态端口( 1024~65535)==**
	应用程序通常使用的范围，一般可与使用的端口号就是在这个范围
<mark style="background: #FF5582A6;">注意</mark>
	端口号类似于进程号，同一时刻只能标志一个进程，可以重复使用

# 子网划分的常见问题

###### 子网划分
- 1，选定的子网掩码将创建多少个子网  
    - x代表非默认子网掩码相较于默认子网掩码借用的主机号的位数。  
- 2，每个子网可包含多少台主机  
    - y代表主机号位数   
- 3，步长求对应八位里面的就行  
- 总![](https://api2.mubu.com/v3/document_image/695bff54-3af2-40d8-8049-1966533d40c3-8070188.jpg) 

###### 例题
- 题：  
    - 1，210.33.5.0；  
    - 2，A类就第一个，x =3，有八个子网![](https://api2.mubu.com/v3/document_image/1f8c643a-6acb-4dee-9542-a8d815179274-8070188.jpg)
    - 3，2^x >= 5 x=3 255.255.255.224 30  
    - 4， 2^13 2^11-2 步长： 256-248 = 8 (248在第三段，所以一开始要加在第三段里面)  
    - 子网范围内第一个就是网关，最后一个就是广播地址![](https://api2.mubu.com/v3/document_image/2e168509-6eff-4083-89e1-c51d01d59df6-8070188.jpg)![](https://api2.mubu.com/v3/document_image/a8cf478b-f401-4d90-841e-4e002b4d36ab-8070188.jpg)


# 数据包的组装、拆解

![[Pasted image 20240513170040.png]]

###### 链路层封包格式
![[Pasted image 20240513170506.png]]

类型：用来确定以太网后面跟的是哪个协议


###### 网络层、传输层封包格式

![[Pasted image 20240513171340.png]]

# 网络应用程序开发流程

###### TCP——面向链接通信
电话系统服务模式的抽象，
**==每一次完整的数据传输都要经过建立连接、使用连接、终止连接的过程==**
本质上,连接是一个管道,收发数据不但顺序一致,而且内容相同，保证数据传输的可靠性，类似与固定电话。
![[Pasted image 20240513171934.png]]
###### UDP——面向无连接通信

邮件系统服务模式的抽象
每个分组都携带完整的目的地址，在 **==传输时并不事先建立连接，而是直接发送数据，但是传输速度快==**
1. 不能保证分组的先后顺序
2. 不进行分组出错的恢复和重传
3. 不保证数据传输的可靠性
![[Pasted image 20240513172226.png]]

# 阻塞和非阻塞
阻塞和非阻塞模式是指程序在等待调用结果时的状态。  
阻塞：程序一直等待，直到操作完成或有错误发生 ，不占用CPU， 
非阻塞：程序立即返回结果，并不会等待操作完成 ，占用CPU，

###### 函数阻塞
对于函数（recvfrom）本身不是阻塞的，是socket默认带有阻塞属性，所以会产生阻塞，可以去除其阻塞属性（ioctlsocket）![[Pasted image 20240530113714.png]]
###### 发送和接收阻塞 
###### 缓冲区：
接收缓冲区和发送缓冲区  
    1. 操作系统在创建socket时分配一个发送缓冲区和一个接收缓冲区，调用recvfrom函数时是从接收缓冲区中把数据拷贝到应用程序的空间  
    2. 调用sendto函数时是把数据拷贝到发送缓冲区  
    3. 查询发送缓冲区和接收缓冲区的大小![](https://api2.mubu.com/v3/document_image/4e9c288d-73df-4b0c-8a54-8210477a6a44-8070188.jpg)  
###### 发送的阻塞和非阻塞  
当发送缓冲区剩余空间不足时，阻塞发送就是等待空间足够大后，再往缓冲区内拷贝数据  
当发送缓冲区剩余空间不足时，非阻塞发送就是有多少空间就往里拷贝多少数据，剩余的数据由应用程序自己处理



# C/S与B/S模型
###### C/S架构通信模式

***C/S模型是客户端/服务端模型，具有较高的灵活性和可扩展性，适用于需要在客户端和服务器之间进行复杂交互和数据处理的应用场景，可以使用任意协议***

无论采用面向连接的还是无连接，两个进程通信过程中，大多采用 C/S 架构
client 向 server 发出请求,server 接收到后提供相应的服务
在通信过程中往往都是 client 先发送请求，而 server 等待请求然后进行服务
客户端时主动的，服务端时被动响应的
![[Pasted image 20240513172314.png]]

**==C/S架构示例==**：
![[Pasted image 20240513172737.png]]

**==server 工作过程==**
1. 打开一通信通道并告知本地主机,它愿意在一特定端口(如 80)上接收客户请求
2. 等待客户请求到达该端口
3. 接收客户请求，并发送应答信号,激活一新的线程处理这个客户请求
4. 服务完成后,关闭新线程与客户的通信链路

**==client 工作过程==**
1. 打开一通信通道并连接到服务器特定端口
2. 向服务器发出服务请求,等待并接收应答
3. 根据需要继续提出请求
4. 请求结束后关闭通信通道并终止


###### B/S架构通信模式

***B/S模型是浏览器/客户端模型，具有较低的客户端依赖性和易于维护的特点，适用于需要广泛分发和跨平台支持的应用场景，只能使用HTTP和HTTPS协议***