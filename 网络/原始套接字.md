
# TCP，UDP回顾

**==数据报式套接字(SOCK DGRAM)==**
1、无连接的 socket,针对无连接的 UDP 服务
2、可通过邮件模型来进行对比
![[Pasted image 20240524131913.png]]



**==流式套接字(SOCK STREAM)==**
1、面向连接的 socket.针对面向连接的 TCP 服务
2、可通过电话模型来进行对比

***这两类套接字似乎涵盖了 TCP/IP 应用的全部***

<mark style="background: #FF5582A6;">注意：</mark>
1. TCP 与UDP 各自有独立的 port 不影响
2. 一个进程可同时拥有多个 port
3. 不必关心 tsp/ip协议实现的过程

![[Pasted image 20240524132335.png]]
#### UDP编程回顾
![[Pasted image 20240524132655.png]]
###### client
1、创建socket接口
2、定义sockaddr in变量，其中ip、port为目的主机的信息
3、可发送0长度的数据包
###### server
1、bind本地主机的ip、port等信息
2、接收到的数据包中包含来源主机的ip、port信息

#### TCP编程回顾
![[Pasted image 20240524133339 1.png]]
###### client
1. connect 来建立连接
2. send、recv收发数据
3. 不可发送 0 长度的数据
###### server
1. bind 本地主机的 p、pot 等信息
2. listen 把主动套接字变为被动
3. accept 会有新的返回值，每有一个客户端连接就有一个返回值
4. 多进程、线程完成并发
# 原始套接字概述，创建

#### 原始套接字概述
**==原始套接字 (SOCK RAW)==**

1. 一种不同于SOCK STREAM、SOCK DGRAM 的套接字，它实现于系统核心
2. 可以接收本机网卡上所有的数据(数据包).对于监听网络流量和分析网络数据很有作
3. 开发人员***可发送自己组装的数据包***到网络上
4. 广泛应用于高级网络编程
5. 网络专家、黑客通常会用此来编写奇特的网络程序


###### 流式套接字只能收发
TCP 协议的数据
###### 数据报套接字只能收发
UDP地议的数据
###### 原始套接字可以收发那些数据
1. 内核没有处理的数据包，因此要访问其他协议
2. 发送的数据需要使用，原始套接字(SOCK RAW)
![[Pasted image 20240524134238.png]]

#### 创建原始套接字

```cpp
int socket (PF_PACKET，SOCK_RAW,protocol);
/*
功能
	创建链路层的原始套接字
参数
	protocol: 指定可以接收或发送的数据包类型
		ETH_P_IP:IPV4 数据包
		ETH_P_ARP:ARP 数据包
		ETH_P_ALL:任何协议类型的数据包
返回值:
成功(>0):链路层套接字,失败(<0):出错
*/
```
###### 创建链路层原始套接字

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/socket.h> //socket
#include <sys/types.h>
#include <arpa/inet.h>  //gtons inet_addr
#include <netinet/in.h> //sockaddr_in
#include <unistd.h>     //close，文件描述符
#include <stdlib.h>     //exit
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <netinet/ether.h>//ETH_P_ALL
#define len 128
using namespace std;
int main ()
{
    int sockfd;
    if ((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) == -1)
    {
        cout<<"fail to socket"<<endl;
        exit (1);
    } 
    cout<<"sockfd = " <<sockfd<<endl;

    return  0;
    
}
```
<mark style="background: #FF5582A6;">注意：</mark>
原始套接字的代码运行时需要管理员权限
![[Pasted image 20240524140211.png]]


# 数据包详解
###### 以太网帧结构
![[Pasted image 20240529220933.png]]
***MSS最大为1460个字节***

如下图所示，是网上的数据包的组包过程，其解包过程正好相反，首先分析以太网得到MAC然后再依次分析，比如IP、PORT等
![[Pasted image 20240524204555.png]]

使用原始套接字进行编程开发时,首先要对不同协议的数据包进行学习.需要手动对 P、TCP、UDP、ICMIP等
包头进行组装或者拆解
ubuntu24 .04 中描述网络协议结构的文件如下:
![[Pasted image 20240524140811.png]]
在TCP/IP 协议栈中的每一层为了能够正确解析出上层的数据包，从而使用一些“协议类型”来标记，详细如下图
![[Pasted image 20240524151907.png]]
![[Pasted image 20240524140914.png]]


###### UDP的封包格式
![[Pasted image 20240524150151.png]]

1.源端口号:发送方端口号
2.目的端口号:接收方端口号
3.长度: UDP用户数据报的长度，最小值是8(仅有首部)
4.校验和:检测UDP用户数据报在传输中是否有错，有错就丢弃

###### IP封装包格式
![[Pasted image 20240524150906.png]]

1. 版本: IP协议的版本。通信双方使用过的IP协议的版本必须一致，目前最广泛使用的IP协议版本号为4(即IPv4)
2. 首部长度:单位是32位 (4字节)
3. 服务类型:一般不适用，取值为0。前3位:优先级，第4-7位:延时，吞吐量，可靠性，花费。第8位保留
4. 总长度:指首部加上数据的总长度，单位为字节。最大长度为65535字节。
5. 标识(identification):用来标识主机发送的每一份数据报。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。
6. 标志 (flag):目前只有两位有意义。
	1. 标志字段中的最低位记为MF。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。
	2. 标志字段中间的一位记为DF，意思是“不能分片”，只有当DF=0时才允许分片
7. 片偏移: 指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以8字节为偏移单位。
8. 生存时间:TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个段。路由器在转发数据之前就把TTL值减一，当TTL值减为零时，就丢弃这个数据报。通常设置为364、128.
9. 协议:指出此数据报携带的数据时使用何种协议，以便使目的主机的P层知道应将数据部分上交哪个处理过程，常用的ICMP(1),IGMP(2),TCP(6),UDP(17),IPv6 (41)
10. 首部校验和：**==只校验数据报的首部，不包括数据部分。==**
11. 源地址:发送方P地址  
12. 目的地址:接收方IP地址
13. 选项：用来定义一些任选项，如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。一般忽略不计。

###### Etherbet封包格式
![[Pasted image 20240524151643.png]]

![[Pasted image 20240524151907.png]]

1.CRC、PAD 在组包时可以忽略
2.FCS
**==CRC即循环冗余校验码==**：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环几余检查是一种数据传输检错功能，对数据进行h多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。

###### TCP封包格式
![[Pasted image 20240524152209.png]]
1. 源端口号:发送方端口号
2. 目的端口号:接收方端口号
3. 序列号:本报文段的数据的第一个字节的序号
4. 确认序号:期望收到对方下一个报文段的第一个数据字节的序号
5. 首部长度(数据偏移): TCP报文段的数据起始处距离TCP报文段的起始处有多远，即首部长度。单位:32位，即以4字节为计算单位。
6. 保留: 占6位，保留为今后使用，目前应置为0
7. 紧急URG:此位置1，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送
8. 确认ACK:仅当ACK=1时确认号字段才有效，TCP规定，在连接建立后所有传达的报文段都必须把ACK置1
9. 推送PSH:当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push) 操作，这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去，接收方收到PSH=1的报文段，就尽快地(即“推送”向前)交付给接收应用进程，而不再等到整个缓存都填满后再向上交付
10. 复位RST: 用于复位相应的TCP连接
11. 同步SYN: 仅在三次握手建立TCP连接时有效。当SYN=1而ACKO时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1.因此，SIN置1就表示这是一个连接请求或连接接受报文
12. 终止FIN:用来释放一个连接。当FIN1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。
13. 窗口:指发送本报文段的一方的接收窗口(而不是自己的发送窗口)
14. 校验和:校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上12字节的伪头部
15. 紧急指针:仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)，即指出了紧急数据的末尾在报文中的位置，注意:即使窗口为零时也可发送紧急数据
16. 选项:长度可变，最长可达40字节，当没有使用选项时，TCP首部长度是20字节


###### ICMP封包格式

![[Pasted image 20240613124125.png]]

![[Pasted image 20240613124456.png]]
![[Pasted image 20240524152739.png]]
<mark style="background: #FF5582A6;">注意：</mark>
不用的类型值以及代码值，代表不同的功能

ping命令就是基于ICMP协议实现的
![[Pasted image 20240613124317.png]]
![[Pasted image 20240613124636.png]]
![[Pasted image 20240613125145.png]]
TTL：每经过一台三层设备就会减一，当减到0时，三层设备就会丢弃该数据包，返回ICMP数据包

# 编程实例-分析MAC数据包
###### 链路层数据格式
![[Pasted image 20240524193546.png]]
###### 代码实现
```cpp
#include <iostream>
#include <stdio.h>
#include <sys/socket.h> //socket
#include <sys/types.h>
#include <arpa/inet.h>  //gtons inet_addr
#include <netinet/in.h> //sockaddr_in
#include <unistd.h>     //close，文件描述符
#include <stdlib.h>     //exit
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <netinet/ether.h> //ETH_P_ALL
#define len 128
using namespace std;
int main()
{
    // 创建原始套接字
    int sockfd;
    if ((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) == -1)
    {
        perror("fail to socket");
        exit(1);
    }

    // 接收数据并分析
    unsigned char msg[1600] = "";
    while (1)
    {

        // recvfrom,recv,read都可以使用
        if (recvfrom(sockfd, msg, sizeof(msg), 0, NULL, NULL) == -1)
        {
            perror("fail to recvfrom");
            exit(1);
        }

        // 分析接收到的数据包
        char dst_mac[18] = "";
        char src_mac[18] = "";
        unsigned short type;
        int t = 0, k = 0;
        sprintf(dst_mac, "%x:%x:%x:%x:%x:%x", msg[0], msg[1], msg[2], msg[3], msg[4], msg[5]);
        sprintf(src_mac, "%x:%x:%x:%x:%x:%x", msg[6], msg[7], msg[8], msg[9], msg[10], msg[11]);
        type = ntohs(*(unsigned short *)(msg + 12));

        cout << "源MAC：" << src_mac << "--->" << "目的MAC：" << dst_mac << endl;
        cout << "type = " <<hex<< type << endl;//hex表示按16进制输出
    }
    return 0;
}
```

**==执行结果==**
IP地址全是0表示没有通信过程
![[Pasted image 20240524201634.png]]


# 练习- 网络数据分析器

###### ARP数据解析图
![[Pasted image 20240524203421.png]]

<mark style="background: #FF5582A6;">说明：</mark>
1. ARP的TYPE为0x0806
2. buf为unsinged char
3. 所有数据均为大端存储


###### IP数据解析图
![[Pasted image 20240524204248.png]]
<mark style="background: #FF5582A6;">说明：</mark>
1. ARP的TYPE为0x0800
2. buf为unsinged char
3. 所有数据均为大端存储

如下图所示，是网上的数据包的组包过程，其解包过程正好相反，首先分析以太网得到MAC然后再依次分析，比如IP、PORT等
![[Pasted image 20240524204555.png]]

#### 网络数据分析器
在很多时候需要对网络上的数据进行抓取，然后进行分析，此“网络数据分析器”就是模仿现实开发中的抓
包工具而进行的
运行 demo 现象如下:
![[Pasted image 20240524201931.png]]

###### 实现原理
通过下面两图以及[[#数据包详解|上述各种的封包方式]]就可以实现上述功能，先通过类型确定是数据包类型在按照对应的封包方式来分析即可。
**==网络数据分析图==**
![[Pasted image 20240524151907.png]]
![[Pasted image 20240524202018.png]]
###### 代码实现

> [!NOTE] 功能
> **要求**
> 
> 	1. 分析出ARP/IP/RARP
> 	2. 分析出MAC
> 
> **扩展**
> 
> 	在完成基本要求的前提下，分析出PORT
> 
> **提示**
> 
> 	以root权限运行
> 
> **想一想**
> 
> 	如何捕获途径网卡的数据？

[6.16 代码讲解以及混杂模式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1sZ4y1L7Xi?p=91)
```cpp
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <string.h>
#include <netinet/in.h>
#include <netinet/ether.h>
int main(int argc, char *argv[])
{
    int fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (fd < 0)
        perror("");
    unsigned char buf[1500] = "";
    unsigned char src_mac[18] = "";
    unsigned char dst_mac[18] = "";
    unsigned char dst_ip[16] = "";
    unsigned char src_ip[16] = "";

    while (1)
    {
        bzero(buf, sizeof(buf));
        bzero(src_mac, sizeof(src_mac));
        bzero(dst_mac, sizeof(dst_mac));
        recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL);
        // buf
        sprintf(dst_mac, "%x:%x:%x:%x:%x:%x", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
        sprintf(src_mac, "%x:%x:%x:%x:%x:%x", buf[6], buf[7], buf[8], buf[9], buf[10], buf[11]);
        printf("src_mac=%s --> dst_mac=%s\n", src_mac, dst_mac);
        
        if (buf[12] == 0x08 && buf[13] == 0x00)
        {
            printf("IP\n");
            sprintf(src_ip, "%d.%d.%d.%d", buf[26], buf[27], buf[28], buf[29]);
            sprintf(dst_ip, "%d.%d.%d.%d", buf[30], buf[31], buf[32], buf[33]);
            printf("src_ip=%s --> dst_ip=%s\n", src_ip, dst_ip);
            if (buf[23] == 6)
            {
                printf("TCP\n");
                printf("src_port=%d\n", ntohs(*(unsigned short *)(buf + 34)));
                printf("dst_port=%d\n", ntohs(*(unsigned short *)(buf + 36)));
            }
            else if (buf[23] == 17)
            {
                printf("UDP\n");
            }
        }
        else if (buf[12] == 0x08 && buf[13] == 0x06)
        {
            printf("ARP\n");
        }
        else if (buf[12] == 0x80 && buf[13] == 0x35)
        {
            printf("RARP\n");
        }
    }

    return 0;
}
```


#### 混杂模式

1. 指一台机器的网卡能够接收所有经过它的数据包(目的MAC并不是你自己)，而不论其目的地址是否是它。  
2. 一般计算机网卡都工作在非混杂模式下，如果设置网卡为混杂模式需要root权限

###### linux下设置  

**==通过命令行设置==**
1. 设置混杂模式：ifconfig eth0 promisc  
2. 取消混杂模式：ifconfig eth0 -promisc  

**==通过程序设置==**
![[Pasted image 20240524211005 1.png]]
###### windos下通过特定的软件实现

# sendto 发送数据
#### 用sendto发送原始套接字数据
```cpp
sendto(sock_raw_fd, msg, msg_len, 0,(struct sockaddr*)&sll, sizeof(sll));  
/*
注意：  
1、sock_raw_fd：原始套接字 文件描述符 
2、msg:发送的消息（封装好的协议数据）  
3、sll:本机网络接口，指发送的数据应该从本机的哪个网卡出去，而不是以前的目的地址，
想一想：  
如何定义sll?
*/
```

###### 本机网络接口

***原始套接字地址结构体***
```cpp
#include <netpacket/packet.h>  
struct sockaddr_ll sll;  
```
![[Pasted image 20240524212509.png]]
***只需要对sll.sll_ifindex赋值，就可使用***

###### 通过ioctl获取网络接口地址
```cpp
#include <sys/ioctl.h>
#include <net/if.h>//struct ifreq
int ioctl (int fd,int request,void *(struct ifreq));
```

![[Pasted image 20240524213645.png]]

**==ioctl参数对照表==**


![[Pasted image 20240524214012.png]]


###### 发送数据demo
```cpp
//获取接口信息
    //将arp请求报文发送出去，通过eth0发送出去
    //使用ioctl函数获取本机网络接口
    struct ifreq ethreq;
    strcpy(ethreq.ifr_name,"eth0",IFNAMSIZ);
    if (ioctl (sockfd,SIOCGIFINDEX,ethreq)==-1){
        perror("fail to ioctl");
        exit(1);
    }
    //设置本机网络接口
    struct sockaddr_ll sll;
    bzero(&sll, sizeof(sll)); // 清空结构体
    sll.sll_ifindex = ethreq.ifr_ifrndex; // 获取本机出去的接口地址
    if (sendto(sockfd, msg, sizeof(msg), 0, (struct sockaddr *)&sll, sizeof(sll)) == -1)
    {
        perror("fail to sendto");
        exit(1);
    }

```

# 练习-MAC地址扫描器（ARP）

#### ARP概述

**==想一想：==**  
如果A(192.168.1.1)向B(192.168.1.2)发送一个数据包，那么需要的条件有ip、port、使用的协议（TCP/UDP）之外还需要MAC地址，因为在以太网数据包中MAC地址是必须要有的；问怎样才能知道对方的MAC地址？使用什么协议呢？

**==ARP（Address Resolution Protocol，地址解析协议）==**  
1. 是TCP/IP协议族中的一个  
2. 主要用于查询指定ip所对应的的MAC  
3. ***请求方使用广播***来发送请求  
4. ***应答方使用单播***来回送数据  
5. 为了在发送数据的时候提高效率在计算中会有一个**ARP缓存表**，用来暂时存放ip所对应的MAC，在linux中使用ARP即可查看,在xp中使用ARP -a。  
<mark style="background: #FF5582A6;">注意：</mark>
主机3~5分钟会更新这个表，防止中途变化。我调试的时候就会修改网卡的IP地址。

###### 在linux与xp系统下查看ARP的方式

```
linux: arp
xp:arp -a
```

**==ARP缓存表==**
暂时存放与主机通信过的其他的主机的IP地址与MAC地址，会不断更新，
![[Pasted image 20240524220000.png]]

<mark style="background: #FF5582A6;">注意：</mark>
当主机A和主机B通信时，会先查看arp表中有没有对方的mac地址，如果有则直接通信即可，如果没有再调用arp协议获取对方mac地址并将其保存在arp表中

###### 通信的主机如何获取对方的MAC地址

以机器A获取机器B的MAC为例，
1. ***机器A发送ARP请求报文（op=1：ARP请求），报文中MAC地址全写0xFF（广播）***，目的IP写上需要请求那一台主机的IP。
2. 主机B收到信息后对比IP地址，是发给它的数据，所以接受，
3. ***主机B在数据包中获取主机A的MAC地址和IP地址，以单播的新式返回消息（op=2：ARP应答）***
4. 主机A接收到B的数据包，并获得B的MAC地址和IP地址
5. ***进行正常通信，这时双方都是单播***

![[Pasted image 20240524220927.png]]

#### ARP协议格式
![[Pasted image 20240524221956.png]]

1.Dest MAC:目的MAC地址
2.Src MAC : 源MAC地址
3.顿类型 : 0x0806
4.硬件类型 : 1( 以太网 )
5.协议类型 : 0x0800 (IP地址)
6.硬件地址长度:6
7.协议地址长度:4
8.OP : 1( ARP请求)，2( ARP应答 )，3( RARP请求)，4( RARP应答)

#### 向指定的IP发送ARP请求

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/socket.h> //socket
#include <sys/types.h>
#include <arpa/inet.h>  //gtons inet_addr
#include <netinet/in.h> //sockaddr_in
#include <unistd.h>     //close，文件描述符
#include <stdlib.h>     //exit
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <netinet/ether.h>    //ETH_P_ALL
#include <net/if.h>           //struct ifreq
#include <netpacket/packet.h> //struct sockaddr_ll
#include <sys/ioctl.h>
#define len 128
using namespace std;
int main()
{

    int sockfd;
    if ((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) == -1)
    {
        perror("fail to socket");
        exit(1);
    }

    // 1.根据各种协议首部格式构建发送数据报
    unsigned char send_msg[1024] = {
        //--------------组MAC--------14------
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // dst_mac: FF:FF:FF:FF:FF:FF
        0x00, 0x15, 0x5d, 0xb9, 0x92, 0x88, // src_mac: 00:0c:29:75:a6:51
        0x08, 0x06,                         // 类型：0x0806 ARP协议

        //--------------组ARP--------28-----
        0x00, 0x01, 0x08, 0x00,             // 硬件类型1(以太网地址),协议类型0x0800(IP)
        0x06, 0x04, 0x00, 0x01,             // 硬件、协议地址分别是6、4，op:(1：arp请求，2：arp应答)
        0x00, 0x15, 0x5d, 0xb9, 0x92, 0x88, // 发送端的MAC地址
        172, 21, 105, 245,                  // 发送端的IP地址
        0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, // 目的MAC地址（由于要获取对方的MAC,所以目的MAC置零）
        172, 21, 96, 1                // 目的IP地址
    };

    // 2.数据初始化

    struct ifreq ethreq;                        // 网络接口地址
    strncpy(ethreq.ifr_name, "eth0", IFNAMSIZ); // 指定网卡名称
    if (ioctl(sockfd, SIOCGIFINDEX, (char *)&ethreq) == -1)
    {
        perror("fail to ioctl");
        exit(1);
    }

    struct sockaddr_ll sll; // 原始套接字地址结构
    bzero(&sll, sizeof(sll));
    sll.sll_ifindex = ethreq.ifr_ifindex;

    if (sendto(sockfd, send_msg, 14 + 28, 0, (struct sockaddr *)&sll, sizeof(sll)) == -1)
    {
        perror("fail to sendto");
        exit(1);
    }
    unsigned char recv_msg[1600] = "";
    char mac[18] = "";
    while (1)
    {

        if (recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0, NULL, NULL) == -1)
        {
            perror("fail to recvform");
            exit(1);
        }

        if (ntohs(*(unsigned short *)(recv_msg + 12)) == 0x0806)
        {
            if (ntohs(*(unsigned short *)(recv_msg + 20)) == 2)
            {
                sprintf(mac, "%x:%x:%x:%x:%x:%x", recv_msg[6], recv_msg[7], recv_msg[8], recv_msg[9], recv_msg[10], recv_msg[11]);
                cout << "172.21.96." << (unsigned short)send_msg[41] << "--->" << mac << endl;
                break;
            }
        }
    }
    close(sockfd);
    return 0;
}
```

**==运行结果==**
![[Pasted image 20240526153405.png]]