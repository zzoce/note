# 形参与实参
形参在函数中的修改是否会影响主调函数（主函数）中的实际参数，取决于参数是如何传递的。在C++中，参数传递的方式主要有两种：值传递（Pass by Value）和引用传递（Pass by Reference）或指针传递（Pass by Pointer，可以视为引用传递的一种形式）。下面是这两种传递方式的影响和区别：

### 值传递 (Pass by Value)

在值传递中，函数的形参获得实参的一个副本。因此，函数中对形参的任何修改都不会影响到实参。

```cpp
void modifyValue(int x) {
    x = 10; // 只修改了x的副本，不影响原始变量
}

int main() {
    int a = 5;
    modifyValue(a);
    std::cout << a; // 输出5，a未被修改
}
```

### 引用传递 (Pass by Reference)

在引用传递中，形参成为实参的一个别名，对形参的任何修改都会直接影响到实参。

```cpp
void modifyReference(int &x) {
    x = 10; // 直接修改了原始变量a
}

int main() {
    int a = 5;
    modifyReference(a);
    std::cout << a; // 输出10，a被修改
}
```

### 指针传递 (Pass by Pointer)

指针传递本质上是引用传递的一种形式。通过传递实参的地址，函数内部可以通过解引用指针来修改实参的值。

```cpp
void modifyPointer(int *x) {
    *x = 10; // 通过指针修改了原始变量a的值
}

int main() {
    int a = 5;
    modifyPointer(&a);
    std::cout << a; // 输出10，a被修改
}
```

### 总结

- **值传递**：函数中对形参的修改不会影响实参。
- **引用传递和指针传递**：函数中对形参的修改会影响实参。

在设计函数时，选择合适的参数传递方式对于控制函数的行为和实现特定的功能非常重要。例如，如果你想在函数内部修改调用者的数据，应使用引用传递或指针传递；如果你想保护原始数据不被修改，应使用值传递。


# 数组的值传递
在C++中，数组不能直接通过值传递给函数。这是因为数组作为函数参数时，会退化（decay）成指向其首元素的指针。因此，当你尝试将数组作为值传递给函数时，实际上传递的是数组首元素的地址，而不是整个数组的副本。这意味着函数中对数组的任何修改都会影响到原始数组，这与值传递的定义（即应该创建一个副本，原始数据不受影响）相违背。

### 解决方法

虽然不能直接通过值传递数组，但有几种方法可以实现类似的效果，或者更好地管理数据。

#### 1. 使用标准库容器

最推荐的方法是使用C++标准库中的容器，如`std::vector`或`std::array`，这些容器可以通过值传递给函数，从而创建数据的副本。

```cpp
#include <vector>
#include <iostream>

void modifyVector(std::vector<int> vec) {
    vec[0] = 10; // 修改的是vec的副本，不影响原始vector
}

int main() {
    std::vector<int> v = {1, 2, 3};
    modifyVector(v);
    std::cout << v[0]; // 输出1，原始vector未被修改
}
```

#### 2. 使用std::array（固定大小数组）

对于大小已知且不变的数组，可以使用`std::array`，它也支持通过值传递。

```cpp
#include <array>
#include <iostream>

void modifyArray(std::array<int, 3> arr) {
    arr[0] = 10; // 修改的是arr的副本，不影响原始array
}

int main() {
    std::array<int, 3> a = {1, 2, 3};
    modifyArray(a);
    std::cout << a[0]; // 输出1，原始array未被修改
}
```

#### 3. 手动复制数组

如果你必须使用原始数组，可以在函数内部手动创建数组的副本，并对副本进行操作。但这种方法较为繁琐，且易出错，不推荐使用。

### 总结

虽然不能直接通过值传递数组，但推荐使用`std::vector`或`std::array`来代替原始数组。这些容器不仅可以通过值传递，而且提供了更多的功能和更好的安全性。如果必须使用原始数组，考虑手动复制数组或者重新考虑设计，以避免直接操作原始数据。

# 数组做参数
**以二维数组为例**：
在C++中处理二维数组并将其作为参数传递给函数时，你可以采用类似于一维数组的几种方法，但需要对它们进行一些调整以适应二维数组的特性。下面是几种处理二维数组的方法：

### 1. 传递二维数组的指针

当你传递一个二维数组给函数时，可以将其作为指向数组的指针。这种方法需要额外的参数来指定数组的维度。

```cpp
#include <iostream>

void print2DArray(int* arr, int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            std::cout << *(arr + i * cols + j) << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int my2DArray[2][3] = {{1, 2, 3}, {4, 5, 6}};
    print2DArray(&my2DArray[0][0], 2, 3);
    return 0;
}
```

### 2. 传递数组的引用（固定大小的二维数组）

对于已知大小的二维数组，可以通过引用将其传递给函数。这样做的好处是可以直接在函数参数中指定数组的尺寸，从而避免在函数调用中传递数组尺寸。

```cpp
#include <iostream>

void print2DArray(int (&arr)[2][3]) {
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 3; ++j) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int my2DArray[2][3] = {{1, 2, 3}, {4, 5, 6}};
    print2DArray(my2DArray);
    return 0;
}
```

### 3. 使用模板函数处理任意大小的二维数组

利用模板，你可以创建一个函数，它能够接受任意大小的二维数组作为参数。

```cpp
#include <iostream>

template<size_t R, size_t C>
void print2DArray(int (&arr)[R][C]) {
    for (int i = 0; i < R; ++i) {
        for (int j = 0; j < C; ++j) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int my2DArray[2][3] = {{1, 2, 3}, {4, 5, 6}};
    print2DArray(my2DArray);
    return 0;
}
```

### 4. 使用 `std::vector<std::vector<T>>`

对于动态大小的二维数组，可以使用`std::vector`的嵌套，这提供了更多的灵活性和方便的接口。

```cpp
#include <iostream>
#include <vector>

void print2DVector(const std::vector<std::vector<int>>& vec) {
    for (const auto& row : vec) {
        for (int val : row) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    std::vector<std::vector<int>> my2DVector = {{1, 2, 3}, {4, 5, 6}};
    print2DVector(my2DVector);
    return 0;
}
```

选择哪种方法取决于你的具体需求，例如数组是否具有固定的大小，以及你是否更倾向于使用原始数组还是标准库容器。在现代C++编程中，推荐使用标准库容器，如`std::vector`，因为它们提供了更高的灵活性和安全性。

# 函数返回数组
**同样以二维数组为例**：
返回二维数组的操作稍微复杂一些，但可以采用类似于返回一维数组的方法。推荐的做法是使用标准库容器，如`std::vector`，因为这种方式既安全又灵活。下面介绍几种返回二维数组的方法：

### 1. 使用`std::vector`的嵌套

这是处理动态二维数组最简单和最灵活的方法。它允许你返回一个动态大小的二维数组，而且不需要担心内存管理。

```cpp
#include <vector>

std::vector<std::vector<int>> create2DVector(int rows, int cols) {
    std::vector<std::vector<int>> vec(rows, std::vector<int>(cols));
    // 初始化vec...
    return vec;
}

int main() {
    auto vec = create2DVector(2, 3);
    // 使用vec...
}
```

### 2. 返回动态分配的二维数组

你可以返回一个指向动态分配的二维数组的指针。这种方法较为复杂，需要手动管理内存。

```cpp
int** create2DArray(int rows, int cols) {
    int** arr = new int*[rows];
    for (int i = 0; i < rows; ++i) {
        arr[i] = new int[cols];
    }
    // 初始化arr...
    return arr;
}

void delete2DArray(int** arr, int rows) {
    for (int i = 0; i < rows; ++i) {
        delete[] arr[i];
    }
    delete[] arr;
}

int main() {
    int rows = 2, cols = 3;
    int** arr = create2DArray(rows, cols);
    // 使用arr...
    delete2DArray(arr, rows);
}
```

### 3. 使用`std::array`或自定义结构（对于固定大小的二维数组）

如果你知道数组的大小在编译时是固定的，可以使用`std::array`或自定义结构。

```cpp
#include <array>

std::array<std::array<int, 3>, 2> create2DArray() {
    std::array<std::array<int, 3>, 2> arr = {{{{1, 2, 3}}, {{4, 5, 6}}}};
    return arr;
}

int main() {
    auto arr = create2DArray();
    // 使用arr...
}
```

### 4. 使用智能指针管理动态二维数组

可以使用`std::unique_ptr`或`std::shared_ptr`来自动管理动态分配的二维数组的内存。

```cpp
#include <memory>

std::unique_ptr<std::unique_ptr<int[]>[]> create2DArray(int rows, int cols) {
    std::unique_ptr<std::unique_ptr<int[]>[]> arr(new std::unique_ptr<int[]>[rows]);
    for (int i = 0; i < rows; ++i) {
        arr[i] = std::make_unique<int[]>(cols);
    }
    // 初始化arr...
    return arr;
}

int main() {
    int rows = 2, cols = 3;
    auto arr = create2DArray(rows, cols);
    // 使用arr...
}
```

在现代C++中，推荐使用标准库容器（特别是`std::vector`的嵌套使用），因为它提供了最大的灵活性和安全性，同时避免了直接管理内存的需要。