# 线段树模板
[【AgOHの数据结构】线段树分裂合并_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1f54y1E7e6/)
线段树是一种可以维护满足结合律的区间信息的数据结构
![[Pasted image 20240225004219.png]]

[P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)
[P3374 【模板】树状数组 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3374)
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define N 100005
#define LL long long
#define lc u<<1
#define rc u<<1|1
LL w[N];
struct Tree{ //线段树
    LL l,r,sum,add;
}tr[N*4];

void pushup(LL u){ //上传
    tr[u].sum=tr[lc].sum+tr[rc].sum;
}
void pushdown(LL u){ //下传
    if(tr[u].add){//lazy标识不为零
        //下放给两个儿子
        tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+1),
        tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+1),
        tr[lc].add+=tr[u].add,
        tr[rc].add+=tr[u].add,
        //lazy表示置零
        tr[u].add=0;
    }
}
void build(LL u,LL l,LL r){ //建树，信息都在叶子结点上
    tr[u]={l,r,w[l],0};
    if(l==r) return;
    LL m=l+r>>1;
    build(lc,l,m);
    build(rc,m+1,r);
    pushup(u);
}
void updata(int u, int x, int k){//点修改
    if (tr[u].l == x && tr[u].r == x){//叶子结点修改
        tr[u].sum+=k;
        return ;
    }
    int m= tr[u].l + tr[u].r >> 1;//非叶子结点则裂开
    if (x<=m) updata(lc,x,k);
    if (x>m) updata(rc,x,k);
    tr[u].sum= tr[lc].sum + tr[rc].sum;
}

void change(LL u,LL l,LL r,LL k){ //区修
    if(l<=tr[u].l&&tr[u].r<=r){
        tr[u].sum+=(tr[u].r-tr[u].l+1)*k;
        tr[u].add+=k;
        return;
    }
    LL m=tr[u].l+tr[u].r>>1;
    pushdown(u);
    if(l<=m) change(lc,l,r,k);
    if(r>m) change(rc,l,r,k);
    pushup(u);
}
LL query(LL u,LL l,LL r){ //区查
    if(l<=tr[u].l && tr[u].r<=r) return tr[u].sum;
    LL m=tr[u].l+tr[u].r>>1;
    pushdown(u);
    LL sum=0;
    if(l<=m) sum+=query(lc,l,r);
    if(r>m) sum+=query(rc,l,r);
    return sum;
}
int main(){
    int n,m,op,x,y,k;
    cin>>n>>m;
    for(int i=1; i<=n; i ++) cin>>w[i];

    build(1,1,n);
    while(m--){
        cin>>op>>x>>y;
        if(op==2)cout<<query(1,x,y)<<endl;
        else cin>>k,change(1,x,y,k);
    }
    return 0;
}
```



####  **例题一**
[Queue - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF91B)
题目大意：
给定 `n` 个正整数$a_1…_n$。需要输出一个 `n` 个数，设此时正在处理第`i`个数：
    - 设 $a_j < a_i,j > i$。
    - 在满足第一条的基础上使`j-i-1`尽可能大，此时` j - i - 1` 即为答案。
$2 \leq n \leq 10^5，a_i \leq 10^9$, 如果对于某个 `i`，不存在任何一个`j`满足 $a_j < a_i$且$j > i$，则输出 `-1`。

**即找最远小于`a[i]`的值的位置**

```cpp
#include<iostream>
#include <queue>
#include <cstring>
#define ll long long
#define lc u<<1
#define rc u<<1|1
using namespace std;
const ll maxn=1e5+5;
ll w[maxn];
struct tree{
	ll l,r,minsum,add;
}tr[maxn*4];

void updata(ll u){//向上修改维护线段树
	tr[u].minsum=min(tr[lc].minsum,tr[rc].minsum);
} 
void build(ll u,ll l,ll r){//建树
	tr[u]={l,r,w[l],0};
	if (l==r){
		return ;
	} 
	ll m=l+r>>1;
	build(lc,l,m);
	build(rc,m+1,r);
	updata(u);
}
ll diancha(ll u,ll k){//点查
	ll t=-1;
	if (tr[u].l==tr[u].r){
		if (tr[u].minsum<k){
			return tr[u].l;
		}
		return -1;
	}

	if (tr[u].minsum<k){
		if(tr[rc].minsum<k){//因为要找小于k的最远值，所以先考虑右边的
		//右边的最小值小于k则不必再考虑左边的
			t=max(t,diancha(rc,k));
		} else if (tr[lc].minsum<k){
			t=max(t,diancha(lc,k));
		}
	}
	
	return t;
}
int main (){
	int n;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>w[i];
	}
	build (1,1,n);
	
	for (int i=1;i<=n;i++)
	{
		ll t = diancha(1,w[i]);
		if (t<=i){
			cout<<"-1 ";
		}else {
			cout<<t-i-1<<" ";
		}
		
	}
	return 0;
} 
```


#### 例题四
[P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3373)
一个线段树上同时进行两种操作区间乘以及区间加
**代码**：
```cpp
#include <bits/stdc++.h>

#define MAXN 100010
#define ll long long

using namespace std;

int n, m, mod;
int a[MAXN];

struct Segment_Tree {
	ll sum, add, mul;
	int l, r;
}s[MAXN * 4];

void update(int pos) {
	s[pos].sum = (s[pos << 1].sum + s[pos << 1 | 1].sum) % mod;
    return;
}

void pushdown(int pos) { //pushdown的维护
	s[pos << 1].sum = (s[pos << 1].sum * s[pos].mul + s[pos].add * (s[pos << 1].r - s[pos << 1].l + 1)) % mod;
	s[pos << 1 | 1].sum = (s[pos << 1 | 1].sum * s[pos].mul + s[pos].add * (s[pos << 1 | 1].r - s[pos << 1 | 1].l + 1)) % mod;
	
	s[pos << 1].mul = (s[pos << 1].mul * s[pos].mul) % mod;
	s[pos << 1 | 1].mul = (s[pos << 1 | 1].mul * s[pos].mul) % mod;
	
	s[pos << 1].add = (s[pos << 1].add * s[pos].mul + s[pos].add) % mod;
	s[pos << 1 | 1].add = (s[pos << 1 | 1].add * s[pos].mul + s[pos].add) % mod;
		
	s[pos].add = 0;
	s[pos].mul = 1;
	return; 
}

void build_tree(int pos, int l, int r) { //建树
	s[pos].l = l;
	s[pos].r = r;
	s[pos].mul = 1;
	
	if (l == r) {
		s[pos].sum = a[l] % mod;
		return;
	}
	
	int mid = (l + r) >> 1;
	build_tree(pos << 1, l, mid);
	build_tree(pos << 1 | 1, mid + 1, r);
	update(pos);
	return;
}

void ChangeMul(int pos, int x, int y, int k,int t) { 
	if (x <= s[pos].l && s[pos].r <= y) {
		if (t==2){
			s[pos].add = (s[pos].add + k) % mod;
			s[pos].sum = (s[pos].sum + k * (s[pos].r - s[pos].l + 1)) % mod;
		}else if (t==1){
			s[pos].add = (s[pos].add * k) % mod;
			s[pos].mul = (s[pos].mul * k) % mod;
			s[pos].sum = (s[pos].sum * k) % mod;
		}
		
		return;
	}
	
	pushdown(pos);
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) ChangeMul(pos << 1, x, y, k,t);
	if (y > mid) ChangeMul(pos << 1 | 1, x, y, k,t);
	update(pos);
	return;
}

ll AskRange(int pos, int x, int y) { //区间询问
	if (x <= s[pos].l && s[pos].r <= y) {
		return s[pos].sum;
	}
	
	pushdown(pos);
	ll val = 0;
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) val = (val + AskRange(pos << 1, x, y)) % mod;
	if (y > mid) val = (val + AskRange(pos << 1 | 1, x, y)) % mod;
	return val;
}

int main() {
	scanf("%d%d", &n, &mod);
	
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	
	build_tree(1, 1, n);
	cin>>m;
	for (int i = 1; i <= m; i++) {
		int opt, x, y;
		scanf("%d%d%d", &opt, &x, &y);
		if (opt == 3) {
			printf("%lld\n", AskRange(1, x, y));
		}else {
			int k;
			scanf("%d", &k);
			ChangeMul(1, x, y, k,opt);
		}
	}
    
	return 0;
}
```


####  例题三
[P3740 [HAOI2014] 贴海报 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3740)
不需要建树的线段树，每一步大操作都是一次性的，且树上只存储少量的信息，在不建树的情况下可以节省很多空间复杂度

**解题思路**：
 线段树 维护区间是否被染色：区间修改没被染色的点，标记，`++ans`；如果区间的点全被染过色，那`ans`不变。
 **注意**数据的处理顺序与输入顺序相反。因为最后输入的在最上面，一定可以`ans++`，所以先处理，之后处理先输入的数据，如果它需要的区间已经被标记则表示它被后输入的覆盖了，于是不能`ans++`，直接`return`。可以结合代码在仔细理解

**代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#define ll long long
#define lc u<<1
#define rc u<<1|1 
using namespace std;
const int maxn=1e7+5;
bool vis[maxn<<2];
bool flag;
int read()
{
    int now=0;char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')now=(now<<3)+(now<<1)+c-'0',c=getchar();
    return now;
}
void updata(int u){
	vis[u]=vis[lc]&&vis[rc];
}
void Modify(int u,int l,int r,int L,int R){
	if (vis[u]){
		return ;
	}
	if (L<=l&&R>=r){
		flag=true;
		vis[u]=true;
		return ;
	}
	int m=(l+r)>>1;
	if (L<=m){
		Modify(lc,l,m,L,R);
	}
	if (R>m){
		Modify(rc,m+1,r,L,R);
	}
	updata(u);
	return ;
} 
int main ()
{
	int n,m;
	cin>>n>>m;
	int a[1005],b[1005];
	for (int i=m;i>=1;i--){
		cin>>a[i]>>b[i];
	}
	int ans=0;
	for (int i=1;i<=m;i++){
		flag=false;
		Modify(1,1,n,a[i],b[i]);
		if (flag){
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

# 线段树分裂合并

[P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1f54y1E7e6/?p=3)
#### 例题
[P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5494)

**题意描述**：
给出一个可重集 𝑎（编号为 1），它支持以下操作：

`0 p x y`：将可重集 𝑝 中大于等于 𝑥且小于等于 𝑦 的值移动到一个新的可重集中（新可重集编号为从 2 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 𝑡t 中的数放入可重集 𝑝，且清空可重集 𝑡（数据保证在此后的操作中不会出现可重集 𝑡）。

`2 p x q`：在 𝑝这个可重集中加入 𝑥 个数字 𝑞。//也就是r=l=q，val+=x；

`3 p x y`：查询可重集 𝑝 中大于等于 𝑥x 且小于等于 𝑦 的值的个数。

`4 p k`：查询在 𝑝 这个可重集中第 𝑘 小的数，不存在时输出 `-1`。

**输入格式**

第一行两个整数 𝑛,𝑚n,m，表示可重集中的数在 1∼𝑛1∼n 的范围内，有 𝑚m 个操作。

接下来一行 𝑛n 个整数，表示 1∼𝑛1∼n 这些数在 𝑎a 中出现的次数 (𝑎𝑖≤𝑚)(ai​≤m)。

接下来的 𝑚m 行每行若干个整数，第一个数为操作的编号 𝑜𝑝𝑡opt（0≤𝑜𝑝𝑡≤40≤opt≤4），以**题目描述**为准。

**输出格式**

依次输出每个查询操作的答案。

```cpp
#include <iostream>
#include <cstdio>
#include <ctime>
using namespace std;
//==========================================
const int maxn = 2e5 + 5;
typedef long long ll;
struct Node
{
    int l,r;//表示左右区间
    ll val;//表示元素个数
}sgt[maxn*40];      //? 40 = 2*maxm*log2(maxn)，相当于一个超大的线段树，可拆分
int cnt,root[maxn];//指向线段树的根，表示为一个新的线段树

inline void pushup(int k) { sgt[k].val = sgt[sgt[k].l].val + sgt[sgt[k].r].val; }
void modify(int l,int r,int &k,int p,int x)     // 单点修改:p位置的值加上x，空间复杂度O(logn)
{
    if(!k) k=++cnt;     // 如果到了NIL结点就新建一个
    sgt[k].val += x;    // 单点修改的加法直接一条线上全部加上x即可
    if(l==r) return;
    int m = (l+r)>>1;
    if(p<=m) modify(l, m, sgt[k].l, p, x);      // 在左子树
    else modify(m+1, r, sgt[k].r, p, x);        // 在右子树
}
void merge(int &x,int y)        // 把y结点的内容合并到x结点上，此写法不消耗空间
{
    if(!(x&&y)) x|=y;           // 如果二者有NULL结点
    else 
    {
        sgt[x].val += sgt[y].val;   // 维护加法，直接加就是了
        merge(sgt[x].l, sgt[y].l);  // 递归合并两结点的左子树
        merge(sgt[x].r, sgt[y].r);  // 递归合并两结点的右子树
    }
}
int split(int l,int r,int &k,int x,int y)   // 从k中分离出[x,y]区间并返回新结点编号，空间复杂度O(2logn)
{
    int n = ++cnt;
    if(x<=l&&y>=r)      // 如果k结点维护的区间在[x,y]中
    {
        sgt[n] = sgt[k];    // 直接拿过来便是
        k = 0;              // 置为NULL，断掉联系
    }
    else 
    {
        int m = (l+r)>>1;
        if(x<=m) sgt[n].l = split(l, m, sgt[k].l, x, y);        // 若左子树中有区间信息
        if(y>m)  sgt[n].r = split(m+1, r, sgt[k].r, x, y);      // 若右子树中有区间信息
        pushup(k);
        pushup(n);      // 更改后记得更新值
    }
    return n;
}
ll query(int l,int r,int k,int x,int y)     // 区间查询
{
    if(x<=l&&y>=r) return sgt[k].val;
    int m = (l+r)>>1;
    ll sum = 0;
    if(x<=m) sum += query(l,m,sgt[k].l,x,y);
    if(y>m)  sum += query(m+1,r,sgt[k].r,x,y);
    return sum;
}
ll query(int l,int r,int k,int kth)         // 单点查询
{
    if(l==r) return l;
    int m = (l+r)>>1;
    if(kth<=sgt[sgt[k].l].val) return query(l,m,sgt[k].l,kth);
    else return query(m+1,r,sgt[k].r,kth-sgt[sgt[k].l].val);
}
signed main(signed argc, char const *argv[])
{
    clock_t c1 = clock();
#ifdef LOCAL
    freopen("in.in", "r", stdin);
    freopen("out.out", "w", stdout);
#endif
    //======================================
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        modify(1,n,root[1],i,x);            // 初始状态下值都为0，所以加x即为置为x
    }
    int last = 1;
    while(m--)
    {
        int opt,x,y,z;
        cin>>opt>>x>>y;
        switch(opt)
        {
        case 0:
            cin>>z;
            root[++last] = split(1, n, root[x], y, z);
            break;
        case 1:
            merge(root[x],root[y]);
            break;
        case 2:
            cin>>z;
            modify(1,n,root[x],z,y);
            break;
        case 3:
            cin>>z;
            cout<<query(1,n,root[x],y,z)<<endl;
            break;
        case 4:
            if(y>sgt[root[x]].val) cout<<-1<<endl;      // 若只有4个元素却来查询第5大元素（例如），那么结果即为-1
            else cout<<query(1,n,root[x],y)<<endl;
            break;
        }
    }
    //======================================
end:
    cerr << "Time Used:" << clock() - c1 << "ms" << endl;
    return 0;
}
```

# 动态开点线段树

[C48 线段树+动态开点 CF915E Physical Education Lessons_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Uh4y1i7hm/)

![[Pasted image 20240503205623.png|1224]]
![[Pasted image 20240504172239.png]]

#### 模板题
[Physical Education Lessons - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF915E)

时间超时，但逻辑正确可参考学习

```cpp
#include <iostream>
#define ll long long
#define lc tr[u].l
#define rc tr[u].r
using namespace std;
const int MAXN=3e5+5;
int tot=1;
struct node {
    int l,r,num,tag;
}tr[MAXN*50];
void pushup (int u){
    tr[u].num=tr[lc].num+tr[rc].num;
}
void pushdown (int u,int l,int r){
    if (tr[u].tag==0){
        return ;
    }
    int m=(l+r)>>1;
    //开点
    if (!tr[u].l) tr[u].l=++tot;
    if (!tr[u].r) tr[u].r=++tot;
    if (tr[u].tag==1)//非工作日
    {
        tr[lc].num=m-l+1;
        tr[rc].num=r-m;
    }else if (tr[u].tag==2){//工作日
        tr[lc].num=tr[rc].num=0;
    }
    tr[lc].tag=tr[rc].tag=tr[u].tag;
    tr[u].tag=0;
}
void change (int &u,int l,int r,int x,int y,int tag){//u必须为引用
	//开点
    if (!u){//因为此处会对u修改
        u=++tot;//如果不是引用，则u的左右子树永远指向0
    }
    if (x<=l&&y>=r){
        if (tag==1){
            tr[u].num=r-l+1;
        }else {
            tr[u].num=0;
        }
        tr[u].tag=tag;
        return ;
    }
    pushdown (u,l,r);
    int m=(l+r)>>1;
    if (x<=m){
        change (lc,l,m,x,y,tag);
    }
    if (y>m){
        change (rc,m+1,r,x,y,tag);
    }
    pushup (u);

}
int main ()
{
    int n,m,root=1;
    cin>>n>>m;
    int opt,l,r;
    for (int i=1;i<=m;i++){
        cin>>l>>r>>opt;
        change (root,1,n,l,r,opt);
        cout<<n-tr[root].num<<endl;
    }
    return 0;
}
```

#### 题二：
[T125847 【模板】动态开点线段树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/T125847)


#### 题三：
[P3960 [NOIP2017 提高组] 列队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3960)


# 可持久化线段树（主席树）

[C49【模板】可持久化线段树（主席树）P3919 可持久化数组_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV11H4y167rp/)

## 理论
![[Pasted image 20240504172813.png]]
## 实现

#### 建树
![[Pasted image 20240504173258.png]]
#### 点修
![[Pasted image 20240504174024.png]]

#### 点查

![[Pasted image 20240504174145.png]]

## 代码实现

#### 例题：
[P3919 【模板】可持久化线段树 1（可持久化数组） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3919)

```cpp
#include <iostream>
#define ll long long
using namespace std;
const int MAXN=1e6+5;
int root[MAXN],tot;
int a[MAXN];
struct node {
    int l,r,num;
}tr[MAXN*25];
void build (int &u,int l ,int r){//建树
    u=++tot;
    if (l==r){
        tr[u].num=a[l];
        return ;
    }
    int m=(l+r)>>1;
    build (tr[u].l,l,m);
    build (tr[u].r,m+1,r);
}
void change (int &u,int v,int l,int r,int p,int num){//点修
    u=++tot;
    tr[u]=tr[v];
    if (l==r){
        tr[u].num=num;
        return ;
    }
    int m=(l+r)>>1;
    if (p<=m){
        change(tr[u].l,tr[v].l,l,m,p,num);
    }else {
        change(tr[u].r,tr[v].r,m+1,r,p,num);
    }
    return ;
}
int query (int u,int l,int r,int p){//点查
   if (l==r){
       return tr[u].num;
   }
   int m=(l+r)>>1;
   if (p<=m){
      return  query(tr[u].l,l,m,p);
   }else {
      return  query (tr[u].r,m+1,r,p);
   }
}
int main ()
{
    int n,m;
    cin>>n>>m;
    for (int i=1;i<=n;i++){
        scanf ("%d",&a[i]);
//        cin>>a[i];
    }
    build (root[0],1,n);

    for (int i=1;i<=m;i++){
        int u,opt,x,num;
        scanf ("%d %d %d",&u,&opt,&x);
//        cin>>u>>opt>>x;
        if (opt==1){
            scanf ("%d",&num);
//            cin>>num;
            change (root[i],root[u],1,n,x,num);
        }else {
            root[i]=root [u];
            cout<<query(root[u],1,n,x)<<endl;
        }
    }
    return 0;
}

```


# 线段树标记永久化

***标记永久化***：就是修改时留下的懒标记并不下穿，也不删除，而是留在打上标记的那一个节点上。当查询经过这个节点时，就加上这个节点的懒标记造成的影响。

***因此***：标记永久化不需要 pushdown以及pushup操作，可以避免一些不必要的计算，来节省时间

![[Pasted image 20240504220148.png]]

```cpp
#include <iostream>
#define ll long long
using namespace std;
const int MAXN=1e6+5;
int root[MAXN],tot;
int a[MAXN];
struct node {
    int l,r,num,tag;//区间和，永久标记
}tr[MAXN*25];
void build(int u,int l,int r){
    tr[u].num=a[l];
    if (l==r){
        return ;
    }
    //lc=u>>1;rc=lc+1;
    build (lc,l,m);
    build (rc,m+1,r);
    tr[u].num=tr[lc].num+tr[rc].num;
}
 void change (int u,int l,int r,int x,int y,ll k){//区修
    tr[u].num+=(min(r,y)-max(l,x)+1)*k;//经过节点更新num
    if (x<=l&&y>=r){//覆盖节点就更新tag
        tr[u].tag+=k;
        return ;
    }
    int m=(l+r)>>1;
    if (x<=m){
        change (lc,l,m,x,y,k);
    }
    if (y>m){
        change (rc,m+1,r,x,y,k);
    }
}
 ll query(int u,int l,int r,int x,int y,ll s){//区查，s路径上tag的累计
    if (x<=l&&y>=r){//覆盖就返回
        return tr[u].num+(min (r,y)-max (x,l)+1)*s;
    }
    ll res=0;
    s+=tr[u].tag;//累计tag，儿子要用
    int m=(r+l)>>1;
    if (x<=m){
        res+=query (lc,l,r,x,y,s);
    }
    if (y>m){
        res+= query(rc,l,r,x,y,s);
    }
    return res;
}
```

# 线段树维护矩阵乘法

矩阵乘法满足
	结合律：(A\*B)\*C=A\*(B\*C)
	分配律：A\*(B+C)=A\*B+A\*C

[线段树维护矩阵 - untitled0 - 博客园 (cnblogs.com)](https://www.cnblogs.com/untitled0/p/sgt-matrix.html)

# 线段树维护哈希

[线段树维护哈希 - zltzlt - 博客园 (cnblogs.com)](https://www.cnblogs.com/zltzlt-blog/p/16797435.html)
