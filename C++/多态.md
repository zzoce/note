在C++中，多态是面向对象编程的一个核心概念，指的是能够使用相同的接口来操作不同类型的对象，并根据对象的实际类型来调用相应的方法。多态性使得同一操作可作用于不同的对象，产生不同的结果，增强了程序的灵活性和可扩展性。C++中实现多态主要有两种方式：静态多态和动态多态。

# 静态多态（编译时多态）

静态多态主要通过[[重载|函数重载和操作符重载]]实现。**==在编译时，编译器根据函数调用的参数类型、数量和顺序来决定调用哪个函数，这种决策是在编译时做出的。==**

- **函数重载**：在同一个作用域内，可以声明几个功能相似的同名函数，但是这些函数的参数列表必须不同（参数类型、个数或者顺序至少有一个不同），编译器会根据调用函数时传入的参数类型和数量来决定具体调用哪个函数。
- **运算符重载**：允许重新定义C++中大多数内置的运算符操作，使得这些运算符可以用于操作自定义类型的对象（例如，类）。通过运算符重载，可以使得自定义类型的对象使用起来更加自然和方便。

**==值得注意的是==**：在C++中，当子类和父类拥有相同名称的函数时，这种情况**不**被称为[[重载]]（Overloading），而是被视为[[重载#重载 vs. 重写（覆盖）|重写]]（Overriding），或者更具体地说，是方法的覆盖，前提是这些函数的参数列表相同。
# 动态多态（运行时多态）

动态多态主要通过虚函数实现。它允许在派生类中重新定义基类中的虚函数，**==以实现运行时的多态性。这种多态性是在程序运行时实现的，依赖于对象的实际类型。==**

## 虚函数

**虚函数**：在基类中使用关键字`virtual`声明的函数。当通过基类指针或引用调用虚函数时，会根据对象的实际类型来调用相应的函数。
 - 如果派生类重写了基类的虚函数，则默认调用派生类的版本，
 - 如果想要使用父类的成员，需要在成员名前加上***类名::*** 用于显式的指定区分，这在[[类之间的关系#继承|继承]]章节提到过；
 - 如果派生类没有重写，则调用基类的版本。

###  示例：

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "Base function" << endl;
    }
};

class Derived : public Base {
public:
    void print() override { // Override关键字不是必需的，但它能提高代码的可读性
        cout << "Derived function" << endl;
    }
};

int main() {
    Base* basePtr;
    Derived derivedObj;

    basePtr = &derivedObj;

    // 调用的是Derived类的print函数
    basePtr->print();

	derivedObj.print();  
	derivedObj.Base::print();

    return 0;
}
```

在这个例子中，`Base`类有一个虚函数`print`，`Derived`类重写了这个函数。通过基类指针`basePtr`调用`print`函数时，实际上调用的是`Derived`类的`print`函数，展示了运行时多态的特性。

###  虚函数指针

虚函数指针（`__vfptr`）：当一个类中定义了虚函数时，在定义对象的内存空间的首地址会多分配出一块内存，标识这块内存的变量称之为虚函数指针(`__vfptr`)。
- **==属于对象的==**，定义对象时才存在（内存空间得以分配），多个对象多份指针。
- 是一个二级指针，类型为 `void**`。
- 在构造的初始化参数列表中进行初始化（编译器默认完成）。
- 指向了一个函数指针数组（虚函数列表，`vftable`）。
- 每个对象中的虚函数指针指向了同一个虚函数列表。

### 虚函数列表

虚函数列表（`vftable`）：是一个函数指针数组，数组每个元素为类中虚函数的地址。
- **==属于类的==**，在编译期存在，为所有对象共享。
- 必须通过真实存在的对象调用，无对象或空指针对象无法调用虚函数。

### 虚函数调用：

虚函数列表是属于类的，父类和子类都会有各自的虚函数列表，`__vfptr`属于对象的，每个对象都有各自`__vfptr`。

#### 原理
1. 由于子类继承父类，不但继承了父类的成员，也会继承父类的虚函数列表。
2. 编译器会检查子类是否有重写父类的虚函数，如果有，在子类的虚函数列表中会替换掉父类的虚函数，一般称之为覆盖，覆盖后便指向了子类的虚函数。
3. 如果子类没有重写的父类虚函数，父类虚函数会保留在子类的虚函数列表中。
4. 如果子类定义了独有的虚函数，按顺序依次添加到虚函数列表结尾。以上这些过程在编译阶段就完成了。

#### 流程
1. 定义对象获取对象内存首地址中的`__vfptr`。
2. 通过`__vfptr`指针间接引用到虚函数列表`vftable`。
3. 在虚函数列表中定位到其虚函数地址，通过地址调用真正的虚函数。

### 虚析构

在多态下，父类的指针指向子类的对象，最后在回收空间的时候，是按照父类的指针类型delete的，所
以只调用了父类的析构，子类的析构并没有执行，这样的话就有可能导致内存泄漏。
```cpp
CFather* pFa = new CSon;
delete pFa; //父类的指针，调用父类的析构，相当于 pFa->~CFather();
```

这个问题用虚析构来解决，即把父类的析构函数变为虚析构函数，delete pFa;时，调用析构会发生
多态行为，从而真正调用的是子类的析构，最后回收对象内存空间时，再调用父类的析构。
```cpp
class CFather{
	virtual ~CFather(); //虚析构
};
class CSon:public CFather{
	~CSon(); //即使不加关键字virtual，子类的析构函数默认也为虚析构了
};
```

## 纯虚函数

**纯虚函数**：在基类中声明为`virtual`并初始化为0的函数，如`virtual void func() = 0;`。**==含有纯虚函数的类称为抽象类，抽象类不能实例化对象==**。纯虚函数必须在派生类中被重写，除非派生类也是抽象类。

在多态下，有时抽象出来的父类的虚函数作为接口函数，并不知道如何实现或不需要实现就是为了多态而生的，只有继承的子类才明确如何实现，可以把父类的虚函数变为纯虚函数。纯虚函数的特点是：当前类不必实现，而***子类必须要重写***实现纯虚函数。
```cpp
//抽象类
class CFather{
	virtual void show()=0; //不必实现
};
//具体类
class CSon:public CFather{
	virtual void show(){ //子类一定重写并实现
		...
	};
};
```

包含纯虚函数的类叫 **==抽象类==**，抽象类不能实例化对象，继承这个抽象类的派生类叫 **==具体类==**，具体类必须重写定义抽象类的里面的所有的纯虚函数。
# 总结

多态性是C++面向对象编程的一个强大特性，它允许您使用相同的接口来操作不同的对象，并在运行时根据对象的实际类型来调用对应的方法。通过虚函数实现的动态多态尤其重要，因为它使得程序设计更加灵活和可扩展。***类中的私有的函数，不能为虚函数，否则会有安全隐患***