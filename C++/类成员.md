
# 修饰符

**类成员修饰符**用来修饰类中的变量，函数包括构造函数和析构函数

```cpp
public :对外公开，在类内，类外都可以使用
protected :在类内和子类中可以使用
private :只能在类内使用，默认使用该修饰符
```

# 属性

**类中的属性属于对象**：
**相同的类有相同的属性，但两个对象的属性可能不同**，例如人类都有一个体重的属性但他们的身高可能不同，因此在没有对象的时候亦不会有属性存在，即在没有定义对象之前不会给属性分配内存，但每个对象都会有独属于他的一份属性

# 函数

**类中的函数属于类**：
**函数相当与方法**他表示了对象的行为，比如体重的增加和减少。所以这个方法属于同类的每一个对象，所以同类的所有属性公用这个函数，并且即使没有定义对象依然会给函数内存，并且方法在程序编译时就会存在。它在程序的生命周期内只有一份拷贝，无论你创建了多少个类的对象

# 静态成员

无论是静态成员变量还是静态成员函数，它们都与类的具体实例无关，**==而是属于类本身==**，并且在编译期就存在。这意味着静态成员是由 **==所有对象共享的，不属于任何一个对象实例==**。它们在程序的生命周期内只有一份拷贝，无论你创建了多少个类的对象。***静态成员不属于任何对象，他直接属于类***
例如，如果你想要追踪一个类的所有对象实例的数量，可以使用一个静态成员变量来实现。**静态成员函数同理**

## 实现方法

```cpp
static int m_a;//静态成员变量
static void show(){}//静态成员函数
```

## 静态成员变量

**静态成员变量需要在类外进行初始化**，**==静态成员变量的使用不需要this指针==** 格式：变量类型 类名::变量名 = 初始值，例如
```cpp
double Circle::PI = 3.141592653589793;
```

## 静态成员函数

静态成员函数在类内定义，并且在**类外可以直接使用类名作用域去调用**，即使这是类没有任何一个对象。当然也可以通过对象去调用。，例如：
```cpp
int sum = Math::add(5, 3);//直接通过类调用
```

### 与普通函数的区别
1. **==静态成员函数没有this指针==**，也就是说：在静态成员函数中只能使用静态成员，但普通成员函数可以使用静态成员，
2. 静态成员函数既可以通过类调用也可通过对象调用，普通成员函数只能通过对象调用
# 常成员

## 常量

**==特性==**：在定义时就必须初始化，且之后不能被修改

**==实现方法==**：
1. 静态常量成员类内部直接初始化，使用`static const`或者`static constexpr`来定义该常量，且该种声明不能使用构造函数初始化，只能在声明时直接初始化。
	- 如果使用构造函数进行初始化，那对与每个对象都可以初始化不同值，这显然和静态成员的规则相背
2. 非静态常量的初始化可以通过构造函数来实现，并且构造函数还可以实现对普通变量的初始化
	- **==值得注意的是==**：通过构造函数进行初始化时，是以变量声明的顺序来进行的，如代码所示

```cpp
#include <iostream>
using namespace std;
class MyClass{
public:
    const int myconst;
    const double mypi ;
    static const int mystaticconst=42;
    static constexpr double pi =3.1415926;
    MyClass(int val,double Pi):myconst(val),mypi(Pi){}
};
int main ()
{
    MyClass num(10,3.14159265);
    MyClass sum(100,6.6666666);
    
    cout<<num.myconst<<" " <<num.mystaticconst<<endl;
    printf ("%0.9lf,%0.9lf\n",num.mypi,num.pi);

    cout<<sum.myconst<<" " <<sum.mystaticconst<<endl;
    printf ("%0.9lf,%0.9lf\n",sum.mypi,sum.pi);

    cout<<num.myconst<<" " <<num.mystaticconst<<endl;
    printf ("%0.9lf,%0.9lf\n",num.mypi,num.pi);
    return 0;
}
```

## 指针与常量

**==常量指针==**：常量指针指向一个常量值，你不能通过这个指针来修改它所指向的内容，但是指针本身可以改变，即可以指向另一个地址。这种指针主要用于指向常量数据，保证通过指针操作不会改变所指向的数据。
```cpp
const int* ptr=&a;
//或者
int const* ptr=&a;
// *ptr = 200;//非法操作
ptr=&b;//是合法的
```

**==指针常量==**：指针常量是指指针本身是常量，一旦被初始化之后，它就不能指向另一个地址，但是通过它指向的数据可以修改（除非它指向的也是一个常量）。
```cpp
int* const ptr = &someVariable;
*ptr = 200;//合法操作
//ptr=&b;//非法
```

**==总结==**：
1. **常量指针**：允许改变指针指向的地址，但不允许通过指针修改所指向地址的值。
2. **指针常量**：允许通过指针修改所指向地址的值，但不允许改变指针指向的地址

**==组合==**
```cpp
const int* const ptr = &someConstantVariable;
```
此时既不能修改它指向的地址，也不能修改地址中的内容。==这种指针通常用于函数参数，以确保函数不会修改传入的数据和指针。==

## 常函数

类中的成员函数参数列表后面有`const`修饰时，称之为常函数，其主要作用是为了保护类中的成员变量、限制修改

1. **==对于静态成员变量==**：常函数既可以访问也可以修改
2. **==对于非静态成员变量==**：常函数只可以访问不能够修改
3. **==对于成员函数==**：常函数只能调用其他常函数，不能调用普通成员函数
**==原因==**
- 非常量成员函数中，`this`指针的类型是指向非常量对象的指针，可以通过this指针访问和修改成员
- 常量成员函数中，`this`指针的类型是指向常量对象的指针，既然是常量自然不能够被修改
- 为什么可以修改静态成员变量，***因为它不属于某个对象，是属于类的***
## 常量对象

使用const修饰的对象,***常量对象的***
```cpp
const MyClass obj;
```

**==常量对象不能调用普通成员函数，只能调用常函数==**

当你声明一个对象为常量时，你实际上是在说这个对象（以及通过它的`this`指针访问的所有属性）都是常量。因此，只有那些保证不会修改任何属性状态的函数（即常量成员函数，它们的`this`指针是指向常量对象的）可以被这样的对象调用。这保证了常量对象的不变性，当你使用常量对象调用普通成员函数时，编译器默认它们可能会修改对象的属性而不被允许。

