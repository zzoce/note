
# 横向关系
##  组合（Composition）

组合是一种强关系，表示一种“拥有”或“包含”的关系，其中一个类（容器类）包含另一个类（成员类）的对象作为其成员变量。当容器类被创建或销毁时，其成员类的对象也会相应地被创建或销毁。

```cpp
class CHand{};
class CPeople{
	Chand m_hand;//组合关系
};
```

## 依赖（Dependency）

依赖是一种使用关系，其中一个类的实现依赖于另一个类的定义。如果一个类的方法操纵另一个类的对象，那么这两个类之间就存在依赖关系。依赖表示为一个类使用另一个类的情况，通常是方法的参数、局部变量或静态方法的调用。依赖之间没有生命周期约束关系。**举例**：编程依赖于电脑，但编程结束后电脑不会消失，因为我还要打游戏

```cpp
class CComputer{};
class CPeople {
	void Code (CComputer *pc)//或 CComputer &pc
	{}
};
```

## 关联（Association）

关联是两个类之间的一种平等关系，表示一个类的对象与另一个类的对象有联系，但二者相对**独立**，没有明显的生命周期依赖。***关联可以是双向的，也可以是单向的***。例如，一个教师类和一个学生类可能相互关联，因为教师教授学生，学生被教师教授。**C++语法中，通常在关联的类中定义被关联类对象的指针形式实现两个类之间的关联关系**

```cpp
class CFriend{};
class Cpeople{
	CFriend *m_pFriend;//关联关系
}
```

## 聚合

多个被聚合的对象聚集起来形成一个大的整体，聚合的目的是为了统一进行管理同类型的对象，聚合是一种弱所属关系，被聚合的对象还可以再被别的对象关联，所以被聚合对象是可以共享的。虽然是共享的，聚合代表的是一种更亲密的关系，相当于强版本的关联。**举例**：聚合相当于家庭，关联相当于朋友

```cpp
class CPeople{};
class CFamily{
	Cpeople* m-Pfamily[10];
};
```

# 纵向关系

##  继承

被继承的类叫做基类（父类），继承的类叫派生类（子类），在派生类类名后面加 ***: 继承方式 基类***。通过继承关系，子类可以使用父类的成员。如果子类和父类有同名的成员（**==属于重写而非[[重载]]==** ），***默认使用子类的成员***，如果想要使用父类的成员，需要在成员名前加上***类名::*** 用于显式的指定区分，**==这一点对成员变量和成员函数均适用==**

**继承的优点**：我们可以将类中的一些功能相近、相似的共同的方法，抽离出来放到单独的一个类中，并让其继承这个类，那么抽离出来的类就是父类，将来其他类在增加公共的方法时，我只需要在父类添加一份即可。提高了代码的复用性、扩展性。

```cpp
class CFather{
public:
	int m_a;
	void f(){
        cout<<m_a<<endl;
    }
};
class Cson:public CFather{
public:
	int m_a;
	 void f (){
        cout<<m_a<<endl;
    }
};

int main ()
{
	Cson son(10,29);  
	cout<<son.m_a<<" "<<son.Cson::m_a<<" "<<son.CFather::m_a<<endl;
	son.f();
    son.CFather::f();
    return 0;
}
```

***再次强调***：如果子类和父类有相同函数名的函数，**且参数列表也相同**，这被视为[[重载#重载 vs. 重写（覆盖）|重写]]（Overriding），而不是[[重载]]（Overloading）。重写是面向对象编程中实现多态性的关键机制之一。

### 继承下的构造函数和析构函数

在子类定义对象函数的执行顺序
- **==构造函数==**：父构造->子构造->孙构造
- **==析构函数==**：孙析构->子析构->父析构

在一个子类定义对象时，通过子类的构造函数来调用父类的构造函数，对父类中的成员变量进行初始化
```cpp
#include <iostream>
using namespace std;
class CFather{
public:
	int m_a;
    CFather(int a):m_a(a){}
};
class Cson:public CFather{
public:
	int m_a;
	Cson(int a,int b):CFather(a),m_a(b){}
};
int main ()
{
    Cson son(10,29);
    cout<<son.m_a<<" "<<son.Cson::m_a<<" "<<son.CFather::m_a<<endl;
}
```

### 继承方式

主要和`public、protected、private`三种修饰方式有关，关系如下表

|   继承方式    | 父类中的属性  | 子类中的属性  |
|:-------------:|:-------------:| ------------- |
|  **public**   |  **public**   | **public**    |
|               | **protected** | **protected** |
|               |  **private**  | **不可访问**  |
| **protected** |  **public**   | **protected** |
|               | **protected** | **protected** |
|               |  **private**  | **不可访问**  |
|  **private**  |  **public**   | **private**** |
|               | **protected** | **private**   |
|               |  **private**  | **不可访问**  |
***总结***：
- 父类中的 **==private==** 在子类中绝对不可访问
- 除上条外其他情况：**==访问权限=max(父类定义的权限，子类定义的权限)==**

###  指针
***在继承关系下，允许父类的指针指向子类的对象，但是反过来却不行***。这是面向对象编程的一个核心概念。多态性允许我们通过父类的指针或引用来调用子类对象的方法，使得不同类的对象可以以统一的接口被处理。这种能力提供了极大的灵活性和扩展性，特别是在设计和实现通用的代码结构时。

```cpp
CFather * p = new CSon;
```

### 类成员函数指针

前置知识：[[函数指针与指针函数]]

```cpp
#include <iostream>
using namespace std;
class Math{
public:
    int c;
    Math(int c):c(c){}
    void POW (int a){
        cout<<a*a*c<<endl;
    }
    void sum (int a,int b){
        cout<<a+b+c<<endl;
    }
};
int main ()
{
    Math mymath(10);
    Math *MyMath = &mymath;

    void (Math::*myPOW)(int) =&Math::POW;
    void (Math::*mySUM)(int,int) =&Math::sum;
    (mymath.*myPOW)(6);//普通对象通过指针调用类成员函数
    (MyMath->*myPOW)(8);//指针对象通过指针调用类成员函数


    //使用typedef 进行优化
    typedef void (Math::*MyPOW)(int);
    MyPOW myPow2=&Math::POW;
    typedef void (Math::*MySUM)(int,int);
    MySUM mySUM2=&Math::sum;

    (mymath.*myPow2)(11);
    (MyMath->*myPow2)(12);

    (mymath.*mySUM2)(6,8);
    (MyMath->*mySUM2)(11,12);

    mymath.POW(4);


    return 0;
}
```

**==特点和注意事项**

- 成员函数指针必须与特定类的成员函数相对应，不能指向其他类的成员函数或普通函数。
- ***静态成员函数不需要通过对象来调用***，因此它们可以使用普通函数指针，而不是成员函数指针。
- 使用成员函数指针时，必须注意对象的生命周期，确保在调用成员函数时对象仍然存在。
- 成员函数指针可以指向虚函数。在这种情况下，通过成员函数指针调用虚函数时，将根据对象的实际类型来动态绑定，实现[[多态]]。

#### ***为什么要使用函数指针而不直接使用对象调用函数呢？***
使用函数指针而不是直接调用函数有几个原因和场景，这些原因通常涉及到提高软件的灵活性、可扩展性和复用性。下面是一些使用函数指针的动机和场景：

 **1. 回调函数**

函数指针广泛用于实现回调机制。在这种模式下，一个函数A接受另一个函数B的指针作为参数。然后，A可以在适当的时候调用B。这允许程序在运行时动态决定应调用哪个函数，而不是在编译时静态决定。这种技术常见于事件驱动编程或异步编程中，例如，GUI程序中的事件处理、定时器回调或线程完成的回调。

 **2. 插件架构**

在设计支持插件的系统时，函数指针可以用来实现插件API。通过定义一组特定的函数指针接口，插件可以实现这些接口并在运行时被主程序调用。这种方式允许主程序在不知道插件具体实现的情况下与插件通信，从而增加了软件的可扩展性。

 **3. 策略模式**
 
在策略模式中，函数指针可以用于动态改变算法或操作的行为。通过将函数指针作为参数传递给函数或对象，可以在运行时选择最合适的算法或行为。这种模式在需要根据上下文动态改变策略的情况下非常有用，比如不同的排序算法、不同的渲染技术等。

 **4. 简化代码和避免重复**

在某些情况下，多个函数可能会执行类似的操作，但在处理的对象或数据上有细微差别。通过使用函数指针，可以将共通的逻辑抽象出来，只在需要的地方通过函数指针指定具体差异，这样可以减少代码重复，使代码更加简洁。

 **5. 接口和抽象层**

在某些底层编程或嵌入式系统开发中，函数指针被用来定义硬件操作的抽象层。这样，上层应用可以通过这些抽象层与硬件通信，而不需要关心硬件的具体实现细节。当硬件变更时，只需修改底层的实现而不影响上层应用。

**总结**

虽然直接调用函数是最直接和简单的方法，但在需要灵活性、可扩展性、或者在设计模式和架构层面上，函数指针提供了一种强大的工具，允许开发者编写出更加模块化和可重用的代码。然而，使用函数指针也需要谨慎，因为它可能会使得代码更难理解和维护，特别是在指针被错误使用时。