

C++11 引入了原生的多线程支持，通过在标准库中添加 `<thread>`、`<mutex>`、`<condition_variable>` 和 `<atomic>` 等头文件，为开发者提供了创建和管理线程、同步操作等功能。这些功能是基于操作系统的底层线程管理功能（如 POSIX 线程或 Windows 线程）实现的，允许开发者在 C++ 程序中直接创建和控制线程。



# 线程（`std::thread`）

1. C++中的线程由 `std::thread` 类表示，它允许你指定一个函数或者函数对象，作为线程启动时执行的代码。
2. 创建线程后与主函数同步执行，有可能线程中的函数还没有执行完毕，主函数就已经完成了，导致程序出错。
3. 使用 `join()` 来等待线程完成其任务，或者使用`detach()`线程分离让线程在后台独立运行。
4. `joinable()`返回一个boo值，若县城可与被join()或者detach()则返回true，否则返回false

### 代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

void foo (){
    std::this_thread::sleep_for(std::chrono::seconds(1));//等待一秒
    cout<<"Thread started"<<endl;
}

int main ()
{
    thread t(foo);
    t.join();//等待t线程结束再执行后面的内容
	//t.detacg()//线程分离主函数结束线程依然在后台执行
	/*
	if(t.joinable){
		t.join();
	}
	*/
    cout<<"over"<<endl;
    return 0;
}
```

# 互斥量（`std::mutex`）

1. 互斥量`mutex` 用于保护共享数据，防止多个线程同时访问同一资源，但可能导致死锁
2. 死锁：线程一占用A资源申请B资源，线程二占用B资源申请A资源，导致两个线程互相等待导致死锁
3. `std::lock_guard` 和 `std::unique_lock` 是与互斥量配合使用的锁管理类，帮助保持良好的锁定习惯，防止死锁。

## 代码

### mutex

如下例代码预期输出data值为200000，若不采用互斥量独占，则data值小于200000，因为两个线程同时访问了data变量。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex mtx;//互斥量
void func(int n){
    for (int i=0;i<100000;i++){
        mtx.lock();//给线程独占，禁止其他前程访问，其他线程等待结束占用
        data+=1;
        mtx.unlock();//结束占用
    }
}

int main ()
{
    thread t1 (func,1);
    thread t2 (func,2);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```

### 死锁

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex m1,m2;//互斥量
void func_1(){
    m1.lock();
    std::this_thread::sleep_for(std::chrono::seconds(1));//等待一秒
    m2.lock();
    m1.unlock();
    m2.unlock();
}
void func_2(){
    m2.lock();
    m1.lock();
    m2.unlock();
    m1.unlock();
}
int main ()
{
    thread t1 (func_1);
    thread t2 (func_2);
    t1.join();
    t2.join();

    cout<<"over"<<endl;
    return 0;
}
```

### std::lock_guard和 std::unique_lock

#### lock_guard

`std::lock_guard` 是 C++ 标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。`std::lock_guard` 的特点如下：
- 当构造函数被调用时，该互斥量会被自动锁定。
- 当析构函数被调用时，该互斥量会被自动解锁。

**代码**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
mutex mtx;
void func(){
    for (int i=0;i<100000;i++){
        lock_guard<mutex> lg(mtx);
        data++;
    }
}
int main ()
{
    thread t1 (func);
    thread t2 (func);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```

#### unique_lock

`std::unique_lock` 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。`std::unique_lock` 提供了以下几个成员函数：
- `lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。
- `try_lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 `false`，否则返回 `true`。
- `try_lock_for(const std::chrono::duration<Rep, Period>& rel_time)`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。
- `try_lock_until(const std::chrono::time_point<Clock, Duration>& abs_time)`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。
- `unlock()`：对互斥量进行解锁操作。
    
**代码**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int data=0;
timed_mutex mtx;//支持时间操作的互斥量
void func(){
    for (int i=0;i<5;i++){
        unique_lock<timed_mutex> lg(mtx,defer_lock);//第二个参数表示有限时的等待
        //unique_lock<timed_mutex> lg(mtx);
        if (lg.try_lock_for(chrono::seconds(1))){//等待时间超过1秒就返回false
            this_thread::sleep_for(chrono::seconds(2));//延时两
            data++;
        }

    }
}
int main ()
{
    thread t1 (func);
    thread t2 (func);
    t1.join();
    t2.join();
    cout<<data<<endl;
    cout<<"over"<<endl;
    return 0;
}
```


# 单例模式

单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，可能会导致多个对象被创建，违反了单例模式要求。

`std::call_once` 是 C++11 标准库中的一个函数，用于确保某个函数只会再多线程下只被调用一次。确保单例模式的对象只被创建一个。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

class Singleton{
public:
    static Singleton& getInstance(){
        call_once(m_onceFlag,&Singleton::init);
        return *m_instance;
    }
    void setData(int data){
        m_data+=data;
    }
    int getData() const{
        return m_data;
    }
private:
    Singleton (){}
    Singleton(const Singleton&)=delete;
    Singleton operator=(const Singleton&)=delete;
    static void init(){
        m_instance.reset(new Singleton);
    }
    static unique_ptr<Singleton> m_instance;
    static once_flag m_onceFlag;
    int m_data=0;
};

unique_ptr<Singleton> Singleton::m_instance;
once_flag Singleton::m_onceFlag;

void func(int num){
    Singleton &Snum=Singleton::getInstance();
    Snum.setData(num);
    cout<<Snum.getData()<<endl;
    return ;
}
void fun(int num){
    int a=0;
    a+=num;
    cout<<num<<endl;
    return ;
}

int main ()
{
    thread t1(func,10);
    std::this_thread::sleep_for(std::chrono::seconds(1));//延时一秒
    thread t2(func,20);
    t1.join();
    t2.join();

    cout<<"over"<<endl;
    return 0;
}
```


# 条件变量（`std::condition_variable`）

1. 条件变量用于线程间的同步，可以使一个或多个线程在某些条件下阻塞，直到另一个线程修改条件并通知条件变量。
2. 通常与互斥量一起使用，以保证条件检查和条件变更的原子性。

**==std::condition_variable的步骤如下：==**

1. 创建一个 `std::condition_variable` 对象。
2. 创建一个互斥锁 `std::mutex` 对象，用来保护共享资源的访问。
3. 在需要等待条件变量的地方使用 `std::unique_lock<std::mutex>` 对象锁定互斥锁，并调用 `std::condition_variable::wait()`、`std::condition_variable::wait_for()` 或 `std::condition_variable::wait_until()` 函数等待条件变量。
4. 在其他线程中需要通知等待的线程时，调用 `std::condition_variable::notify_one()`或 `std::condition_variable::notify_all()` 函数通知等待的线程。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
std::mutex g_mutex;
std::condition_variable g_cv;
std::queue<int> g_queue;

void Producer() {
    for (int i = 0; i < 10; i++) {
        {//用于unique_lock自动析构
            std::unique_lock<std::mutex> lock(g_mutex);//互锁
            g_queue.push(i);//任务入队
            std::cout << "Producer: produced " << i << std::endl;
        }
        g_cv.notify_one();//新任务已经入队，通知其他线程
        std::this_thread::sleep_for(std::chrono::milliseconds(100));//休眠100毫秒
    }
}
void Consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(g_mutex);//互锁

        //等待!g_queue.empty()==true条件满足，如果不满足就先执行其他线程
        g_cv.wait(lock, []() { return !g_queue.empty(); });
        //执行
        int value = g_queue.front();
        g_queue.pop();

        //输出
        std::cout << "Consumer: consumed " << value << std::endl;
    }
}
int main() {
    std::thread producer_thread(Producer);
    std::thread consumer_thread(Consumer);
    producer_thread.join();
    consumer_thread.join();
    return 0;
}
```


# 原子操作（`std::atomic`）

1. 原子类型用于无锁编程，保证类型操作的原子性，避免在多线程环境中的数据竞争。
2. 提供了一种更细粒度的同步机制，通常用于计数器或状态标志。



# 示例：交替打印A和B

在 C++ 中实现两个线程交替打印字符A和B各100次，可以使用标准库中的多线程支持，如 `std::thread`，以及同步机制如 `std::mutex` 和 `std::condition_variable`。下面是一个示例程序，展示如何使用这些工具来确保两个线程可以交替执行。

### 示例代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

// 共享资源和同步的相关变量
std::mutex mtx;
std::condition_variable cv;
bool turn = true; // true 表示打印A，false 表示打印B

void print_char(char c, bool my_turn) {
    for (int i = 0; i < 100; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        // 等待正确的条件
        cv.wait(lock, [&]() { return turn == my_turn; });
        // 打印字符
        std::cout << c;
        // 切换轮次
        turn = !turn;
        // 通知其他线程
        cv.notify_one();
    }
}

int main() {
    // 创建两个线程
    std::thread t1(print_char, 'A', true);
    std::thread t2(print_char, 'B', false);

    // 等待线程结束
    t1.join();
    t2.join();

    std::cout << "\nFinished printing." << std::endl;

    return 0;
}
```

### 代码解释

1. **全局变量**：
   - `std::mutex mtx`：互斥量，用于同步对共享资源的访问。
   - `std::condition_variable cv`：条件变量，用于在某种条件下阻塞线程或唤醒线程。
   - `bool turn`：布尔标志，用于控制哪个线程应该打印，以确保A和B交替打印。

2. **函数 `print_char`**：
   - 接受一个字符和一个布尔值，字符表示要打印的字符，布尔值表示该线程的打印轮次。
   - 循环100次，每次循环中，线程首先获取互斥锁。
   - 使用条件变量等待正确的轮次。
   - 打印字符后，切换轮次，并通知其他可能在等待的线程。

3. **主函数 `main`**：
   - 创建两个线程，一个打印'A'，另一个打印'B'。
   - 通过 `join()` 等待这两个线程执行完毕。

### 注意事项

- 使用 `std::cout` 在多线程中可能不是线程安全的，但在这个特定的示例中，由于互斥锁的保护，可以安全地使用。
- 确保线程在任何时候只有一个能够访问共享资源，这里的共享资源是标准输出和控制打印顺序的变量。

这种方式确保了两个线程能够有效且正确地交替执行，同时保持代码的简洁性和易于理解。
