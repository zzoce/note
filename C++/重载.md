# 函数重载

函数重载是C++中一种允许多个同名函数共存的特性，但这些函数的参数列表（参数的类型或数量）必须不同。这意味着你可以根据不同的参数类型或数量来调用相应的函数版本。这是一种多态性的表现形式，使得函数调用更加灵活。

### 函数重载的规则

1. **函数名相同**：重载的函数必须在相同的作用域内，并且名称相同。
2. **参数列表不同**：可以是参数的数量不同，类型不同，或者是参数的顺序不同（只有当参数的类型不完全相同时）。
3. **返回类型不是重载的依据**：仅仅返回类型不同不足以构成函数重载。如果两个函数除了返回类型外其他都相同，会引发编译错误。
4. **const修饰符**：带有const修饰符的参数或者函数本身（如果是成员函数）可以与非const版本的函数构成重载。

### 示例

```cpp
#include <iostream>

// 函数重载示例
void display(int i) {
    std::cout << "Displaying int: " << i << std::endl;
}

void display(double f) {
    std::cout << "Displaying float: " << f << std::endl;
}

void display(int i, double f) {
    std::cout << "Displaying int and float: " << i << ", " << f << std::endl;
}

int main() {
    display(5);       // 调用第一个版本
    display(5.5);     // 调用第二个版本
    display(5, 5.5);  // 调用第三个版本
    
    return 0;
}
```

在这个示例中，`display`函数被重载了三次：一次接受一个整数参数，一次接受一个浮点数参数，最后一次同时接受一个整数和一个浮点数参数。编译器根据调用函数时提供的参数类型和数量来决定调用哪一个版本的函数。

### 重载解析

当调用一个重载的函数时，编译器会根据提供的实参来选择最匹配的函数版本。这个过程称为重载解析。编译器会首先查找完全匹配的函数版本，如果没有找到，它会尝试通过标准转换（如整型提升、浮点数提升等）来找到匹配的函数。如果仍然没有找到，或者找到了多个同样匹配的函数版本，那么会产生编译错误。

### 构造函数重载

在类中，构造函数也可以被重载。这允许创建对象时提供不同的初始化选项。

```cpp
class Rectangle {
private:
    int width, height;
public:
    // 构造函数重载 #1：无参数
    Rectangle() : width(0), height(0) {}

    // 构造函数重载 #2：两个int参数
    Rectangle(int w, int h) : width(w), height(h) {}
};
```

通过重载，`Rectangle`类可以无参数创建，也可以通过提供宽度和高度参数来创建。

### 总结

重载是C++中的一个重要特性，它提高了函数的灵活性，使得同一个函数名可以用于不同的场景。重载的实现依赖于函数的参数列表，而不是返回类型。理解和掌握重载对于编写清晰、高效的C++代码非常重要。



# 函数重写

函数重写（Function Overriding），也称为方法覆盖，是面向对象编程中的一个概念，特别是在使用继承的语言中，如C++、Java等。当子类中的方法与其基类中的一个方法具有相同的名称、返回类型及参数列表时，子类的方法会重写（覆盖）基类中的方法。函数重写允许子类提供一个特定实现，用于替代继承自基类的实现。这是多态性的一种体现。

### 函数重写的规则

1. **函数签名相同**：重写的方法在子类中的声明必须与基类中被重写的方法完全相同，这 **==包括函数名、参数列表以及返回类型==**（在某些语言中，返回类型可以是协变的，即子类方法可以返回基类方法返回类型的子类型）。
2. **访问权限**：子类中重写的方法 **==不能拥有比基类方法更严格的访问权限==**。例如，如果基类方法是`public`的，那么子类中重写的方法也必须是`public`的。
3. **使用`virtual`和`override`关键字**（C++特有）：在C++中，基类中的方法必须被声明为`virtual`，以允许被子类重写。子类中重写的方法可以使用`override`关键字明确表示该方法意图重写基类的方法，这不是必需的，但可以增加代码的可读性和安全性。

### 示例

以下是C++中函数重写的一个简单示例：

```cpp
#include <iostream>

class Base {
public:
    virtual void show() const {
        std::cout << "Base class show" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() const override { // 使用override关键字明确表示重写
        std::cout << "Derived class show" << std::endl;
    }
};

int main() {
    Base* b = new Derived();
    b->show(); // 输出: Derived class show
    delete b;
    return 0;
}
```

在这个例子中，`Derived`类重写了`Base`类中的`show`方法。当通过基类指针调用`show`方法时，由于`show`方法被声明为`virtual`，并且在`Derived`类中被重写，因此调用的是`Derived`类中的`show`方法实现。这展示了多态性的一个关键特征：基类的指针或引用可以被用来调用在派生类中重写的方法。

### 重要性

函数重写是实现多态性的关键机制之一。它允许子类根据需要提供特定的行为实现，同时保持与基类相同的接口。这样，通过基类的引用或指针，可以在运行时调用到派生类中重写的方法，实现运行时多态。

### 重载 vs. 重写（覆盖）

- **重载（Overloading）**：
  - 发生在同一个类中或者在同一作用域内。
  - 函数名相同，但是参数列表必须不同（参数的类型、个数或者顺序）。
  - 重载与函数的返回类型无关。
  - 编译时多态性的一种表现。

- **重写（覆盖，Overriding）**：
  - 发生在两个类之间的父类与子类中。
  - 子类定义一个与父类同名的函数，且参数列表也完全相同。
  - 通常与虚函数（virtual function）一起使用，以实现运行时多态性。
  - 子类的函数可以有不同的行为实现。
  - 重写的目的是允许子类改变或扩展父类中某个行为的具体实现。

#### 示例

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class show" << std::endl;
    }
};

class Derived : public Base {
public:
    // 这里是重写（Overriding），而不是重载
    void show() override {
        std::cout << "Derived class show" << std::endl;
    }
};
```

在这个例子中，`Derived`类的`show`函数重写了`Base`类的`show`函数。因为它们的函数名和参数列表相同，所以这是重写，而不是重载。使用`override`关键字（C++11及以上版本）可以明确指出该函数意图重写基类中的虚函数，这有助于编译器检查和避免错误。

#### 总结

在C++中，如果子类和父类有相同函数名的函数，且参数列表也相同，这被视为重写（Overriding），而不是重载（Overloading）。重写是面向对象编程中实现多态性的关键机制之一。

# 操作符重载

## 类内重载

作为类成员函数，需要用对象调用，并且可以隐藏类成员变量作为第一个参数。在使用时要 **==注意重载操作符的参数类型和顺序==**，

所谓 **==注意重载操作符的参数类型和顺序==**，编译器会根据参数的顺序来判断调用的是哪一个重载，所以在调用时要严格遵守参数顺序

```cpp
class CTest{
public:
    int m_a;
    CTest(){
        m_a = 10;
    }
    int operator+(int a){
        return this->m_a+a;
    }
};
int operator+(CTest &tst，int a){
    return tst.m_a+a;
}
//此时类内类外两个重载的参数循序是相同的，编译器不知道是调用哪个重载
	int a = tst+10; //error C2593: “operator +”不明确

	//消除歧义：
	tst.operator+(10); //类内
	::operator+(tst,10); //类外
```

在调用重载时***可以直接使用操作符，也可以通过对象显示的调用重载的操作符。***

```cpp
class CTest{
private:
	int m_a;
public:
	CTest(){
		m_a = 10;
	}
	int operator+(int a){//隐藏第一个参数
		return m_a+a;
	}
};
int main(){
	CTest tst;
	int a = tst+20;
	int b = tst.operator+(20);
	//参数顺序不同时
	//int c = 20+tst; //非法
return 0;
```

对于单目运算符++，有左++ 和 右++ 两种，为了区分右++，我们需要额外指定一个int类型的参数，这个参数只是用来区分，并无实际意义。

```cpp
class CTest{
	//类内
	int operator++(); //左++
	int operator++(int a); //右++
};
```

## 类外重载

在类外重载时不再能隐藏参数，并且调用方式与类内重载不同，***调用方式时严格对应的***。

```cpp
class CTest{
public:
    int m_a;
    CTest(){
        m_a = 10;
    }
    int operator+(int a){
        return this->m_a+a;
    }
};
int operator+(int a,CTest &tst){
    return tst.m_a+a;
}
int main(){
    CTest tst;
    //根据参数顺序来判断是哪一个重载
    int a = tst+10; //匹配类内重载函数
    int b = tst.operator+(20);//匹配类内重载函数
    int c = 10+tst; //匹配类外重载函数
    cout<<a<<" "<<b<<" "<<c<<endl;
    return 0;
}
```

## 输入输出重载

在C++中，`istream` 是一个表示输入流的类，属于标准库中的 `<istream>` 头文件。它是用于从不同的输入源（如键盘、文件、网络连接等）读取数据的基础设施的一部分。`istream` 是输入流的基类，提供了一系列用于输入操作的成员函数，允许从流中提取（读取）数据。

### 主要特点

- **多态性**：`istream` 类及其成员函数通常被设计为支持多态性，这意味着你可以使用 `istream` 的引用或指针来操作其派生类的对象，如 `ifstream`（用于文件输入）和 `istringstream`（用于字符串输入）等。
- **操作符重载**：`istream` 类重载了 `>>` 操作符，用于从流中提取数据到不同类型的变量中，这使得从输入流读取数据的操作更加直观和方便。
- **状态标志**：`istream` 维护了一组状态标志，用于指示流的当前状态，如是否遇到文件末尾（EOF）、是否发生输入错误等。这些状态可以通过成员函数如 `eof()`, `fail()`, `bad()`, 和 `good()` 来检查。

***ostream同理***

自定义重载输入、输出操作符，一般在类外重载。
```cpp
class CTest{
	public:
	int m_a;
};
//输入，注意参数为类、结构体类型，最好用引用而非值传递
istream& operator>>(istream& is, CTest& tst) {
	is >> tst.m_a;
	return is;
}
//输出，
ostream& operator<<(ostream& os, CTest& tst) {
	os << tst.m_a;
	return os;
}
```

### 继承结构

`istream` 是一个重要的基类，它有多个派生类，包括：

- `ifstream`：用于从文件读取数据。
- `istringstream`：用于从字符串读取数据。
- `istream` 也与 `iostream` 类有关，`iostream` 是用于同时支持输入和输出操作的类。

总之，`istream` 在C++标准库中扮演着处理输入的核心角色，无论是从文件、字符串还是标准输入中读取数据。

## 赋值重载

`operator=` 是一个特殊的成员函数，称为赋值运算符重载。能让其他的类型赋值到当前类对象中，但是如果反过来写则会报错，类型不匹配，因为`operator=`只能在类内重载。
当一个对象被赋予另一个同类型对象的值时，就会调用这个运算符。默认情况下，C++为类提供了一个拷贝赋值运算符，它执行成员到成员的浅拷贝。然而，当类中包含动态分配的内存或其他需要深拷贝的资源时，就需要自定义赋值运算符来确保资源的正确复制和内存管理。
```cpp
class MyClass {
public:
    int *data;

    MyClass(int value) { data = new int(value); }

    // 自定义赋值运算符
    MyClass& operator=(const MyClass& other) {
        if (this != &other) { // 防止自赋值
            delete data; // 释放原有资源
            data = new int(*other.data); // 分配新资源并拷贝内容
        }
        return *this; // 返回当前对象的引用
    }

    ~MyClass() { delete data; } // 析构函数释放资源
};
```

## 对象类型转换

在C++中，对象类型转换涉及将一个对象的类型转换为另一个类型。这可以通过构造函数、赋值运算符或类型转换运算符来实现。

- **通过构造函数**：如果一个类的构造函数只接受一个参数（或所有参数除一个外都有默认值），那么它也可以作为一个转换构造函数，用于将参数类型的对象隐式转换为该类的对象。

```cpp
class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {} // 转换构造函数
};

void func(MyClass mc) {
    // ...
}

func(10); // int 自动转换为 MyClass 类型
```

- **通过赋值运算符**：赋值运算符可以被重载来接受不同类型的参数，从而允许将一个类型的对象赋值给另一个类型的对象。这种情况较少见，通常不推荐这样使用，因为它违反了单一职责原则。
- **通过类型转换运算符**：可以在类内部定义类型转换运算符，使得对象可以被隐式或显式地转换为另一种类型。

```cpp
class MyClass {
public:
    double value;

    MyClass(double  v) : value(v) {}

    // 类型转换运算符
    operator int() const {
        return value;
    }
};

int main ()
{
    MyClass mc(10.1231);
    double myInt = mc; // MyClass 对象自动转换为 int 类型
    cout<<myInt<<endl;
    return 0;
}
```

